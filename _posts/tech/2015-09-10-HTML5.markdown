---
layout: post
title: HTML5学习历程
category: 技术
keywords: 技术,HTML5
---
## 写在前页面

关于H5 C3 JS API 的浏览器版本支持度
可以上[caniuse 网站查询](http://caniuse.com/)

## HTML5初始化代码

{% highlight html %}

<！DOCTYPE html>
<html>
<head>
<meta charset="utf-8">	
<title>html5</title>

</head>
<body>
	<header>
		页面头部
	<hgroup>
		定义一组标题组合
		<h1>Owen的博客</h1>
		<h2>仰望星空的天台</h2>
	</hgroup>
	</header>
	<article>
	用来语意化一篇文章主体
		<aside>侧边栏</aside>
		<section>内容区</section>
	</article>
	<footer>页面底部</footer>
</body>
</html>

{% endhighlight %}

比起之前的版本
简化了很多

主要是用于语意化规范
那么语义化规范有什么用呢？

## 语意化标签的作用

### 1.便于SEO爬虫爬取你的页面(SEO优化)

首先，在语意化标签出来之前
我们是通过CSS给标签添加样式之后
(或者id和class稍微的语意化)
才知道每个布局是干什么的

但是搜索引擎(Search Engine)
是看不到我们整个页面的布局的
所以就很难爬取到有用的信息
这样检索信息的时候，你的页面就很难被找到
没被找到基本上你的网站就很难和大众接轨了

所以html标签的语意化有利于SEO找到你页面的关键信息

世界上还举办了这么个节日
[CSS Naked Day](http://baike.baidu.com/link?url=TnnAkTykYvytO7HU7djxxNXaxBInKo5sIF2w6HyeMOpnjhlQM993Fe8jsU1zy9b7A_4HBbBwDbi4iGV6NWhBca)
CSS裸奔节

用以推动Web标准、提倡简洁为美、使用正确的(x)html语义标记、良好的层次结构。

### 2.便于网站维护人员维护页面

其次，如果当公司让你去维护一个不是你自己写的页面
这时候标签是清一色的 div 或者是 td 标签
你这时候就会觉得眼花缭乱 

有可能把作者叫过来看，他自己也忘了啥是啥了
但是如果我们给加的标签自身添加了语义化的功能

我们维护的时候，一看标签就知道是干什么的了
这样工作也会轻松很多

### 3.有利于一些特殊终端的阅读

再来，我们介绍一些计算机的特殊终端:打印机、扫描器、手机等等
如果需要这些特殊的终端设备识别你的页面
标签语义化也是必不可少

## 其他的一些语义化标签

### figure

{% highlight html %}

用于对元素组合
说白了一般就是用来装<img> 和 <video>
figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。
figcation的子元素 用来解释

{% endhighlight %}

### time

用来标记时间
{% highlight html %}
<p>
	庆祝抗日战争胜利70周年,阅兵日<time> 2015-09-03 </time>
</p>

<p>
	我的<time datetime = "1996-03-05">生日</time>
</p>

{% endhighlight %}

### datalist 和 option

选项列表
当你在表单输入时
自动弹出可能值列表
{% highlight html %}

<input type="text" list="valList" />
<datalist id="valList">
 	<option value="javascript">javascript</option>
   <option value="html">html</option>
  <option value="css">css</option>
</datalist>

{% endhighlight %}

这里又引出了一个新的属性"list"
用来关联可能值列表

### summary 和 details

用于列出文档列表
{% highlight html %}
<details>
<summary>点我,就送屠龙宝刀</summary>
乖乖努力打怪升级,自然就有
</details>
{% endhighlight %}

可以加一个属性Open
使列表默认是展开状态

但是，这个标签暂时还只有Chrome 和 Safari 支持

### dialog

这对标签一般用来语意化一段对话
{% highlight html %}

<dialog>
  <dt>老师</dt>
  <dd>2+2 等于？</dd>
  <dt>学生</dt>
  <dd>4</dd>
  <dt>老师</dt>
  <dd>答对了！</dd>
</dialog>
{% endhighlight %}

### address

用来语意化页面作者和他们的详细信息

### mark

高亮某一段需要高亮的字词或是段落
可以在CSS中使用background修改高亮颜色

### keygen

可以使用keygen为发送的表单添加一个公共密钥
{% highlight html %}
<form action="http://numerhero.github.io" method="get">
用户: <input type="text" name="usr_name" />
公钥: <keygen name="security" />
<input type="submit" />
</form>
{% endhighlight %}

### progess

可以定义一个简陋的进度条
{% highlight html %}
<progress max="100" value="77">
     <!-- 这里用以兼容 不支持该标签的浏览器 -->
     <span>77</span>%
</progress>
{% endhighlight %}

## 如何向下兼容IE8以下版本

{% highlight Javascript %}
因为浏览器允许我们自定义标签
比如

<Owen> 每天都萌萌哒 </Owen>

但是自定义的标签没有任何默认样式
需要自己去添加

虽然旧的浏览器版本没有HTML5这些标签
但是我们可以通过JS脚本创建，并给他们添加CSS属性

这里Google开发了一个兼容脚本:

/*! HTML5 Shiv v3.6.1 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed */
;(function(window, document) {
/*jshint evil:true */
  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }
  
    /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/\w+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video',

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

}(this, document));

{% endhighlight %}

只需外部引用一下就能实现兼容了

## 新增的表单属性

### email

{% highlight html %}

<form>
	<input type="email">
	<input type="submit">
</form>

相当于给输入框加了一个正则表达式
用来粗略的区分你输入的是否是一个正确的邮箱地址
(要真正判断 还得配合AJAX)

对于手机端,还会有一个输入法的转换
当你要输入有邮箱的时候,点击email表单
会从其他语言的输入法 转换为英文输入法

{% endhighlight %}

### tel

{% highlight html %}

<form>
	<input type="tel">
	<input type="submit">
</form>

对于PC端，没有什么特殊变化

对于手机端,还会有一个输入法的转换
当你要输入有电话的时候,点击tel表单
会从其他语言的输入法 数字键盘

一些可选属性：
maxlength : 限制最大值
readonly : 默认只读不可修改
size : 输入数字大小
placeholder : 默认提示
dirname : 
{% endhighlight %}

### url

{% highlight html %}

<form>
	<input type="url">
	<input type="submit">
</form>

和email一样
相当于给输入框加了一个正则表达式
用来粗略的区分你输入的是否是一个网址

对于手机端,还会有一个输入法的转换
当你要输入有网址的时候,点击url表单
会从其他语言的输入法 转换为英文输入法

{% endhighlight %}

### search

{% highlight html %}

<form>
	<input type="search">
	<input type="submit">
</form>

搜索框属性
当你输入的时候，
会出现清空内容的按钮
可以配合其他属性使用

{% endhighlight %}

### range

{% highlight html %}

<form>
	<input type="range">
	<input type="submit">
</form>

数值选择器属性
可以用来给我们选择数值
它底下有这么些属性
step : 数值跨度，即每次数值增加量 默认是1
min  : 最小数值
max  : 最大数值
value: 缺省数值值

其中Opera 浏览器 还特意为range 做了数值刻度

{% endhighlight %}

### number

{% highlight html %}

<form>
	<input type="number">
	<input type="submit">
</form>



另外一个数值选择器属性
也可以用来给我们选择数值
它底下也有这么些属性
step : 数值跨度，即每次数值增加量 默认是1
min  : 最小数值
max  : 最大数值
value: 缺省数值值
{% endhighlight %}

### color

{% highlight html %}

可以供我们使用的一个调色板插件
<form>
	<input type="color" id="incolor" >
</form>

可以添加的值
disabled : 是否可用
autocomplete ：弹出自动候选色(和datalist用的时候使用)
autofocus : 是否获取焦点
list : 关联datalist列表 可以给用户产生候选颜色
value : 缺省色

=== Javascript 简单调用 ===

window.onload = function()
{
	var InputColor = document.getElementById('incolor');
	//使用oninput对象调用
	InputColor.oninput = function()
	{
		document.body.style.backgroundColor = this.value;
	}
}
{% endhighlight %}

### date

{% highlight html %}

<form>
	<input type="date" min="1996-03-05" max="2004-09-22">
</form>

一个插入日期的控件

一些可选属性
min : 最小日期
max : 最大日期
{% endhighlight %}

### datatime-local

{% highlight html %}

用法和date差不多
用于选取本地时间
<form>
	<input type="datetime-local" >
</form>

但是貌似没有min 和 max 属性
{% endhighlight %}

### time、week、month

data可以向下细分为

time : 只显示时间
week : 只显示星期
month: 只显示月

## 一些表单的属性

placeholder : 提示信息

autocomplete : 历史输入信息 (on / off)
autofocus : 打开页面自动获取表单焦点 直接加(例子如下)
require : 强制用户填写拥有该属性的表单 直接加(注意:这里直接加的话写的是required 多个d)

pattern : 简单的表单正则表达式(列如：pattern="\d{1,5}" 限制表单中只能填入1-5个数字)
(注意:由于require 和 pattern 是写在行间的属性，所以使用浏览器的修改功能 可以被用户轻易的破除)

formaction : 用来添加一个新的提交路径
formnovalidate : 关闭验证，直接提交
{% highlight html %}

<form action="http://www.baidu.com">
	<input type="text" placeholder="输入的内容"  pattern="\d{1,5}" autofocus required  autocomplete="off">
	<input type="submit" value="提交百度">
	<input type="submit" value="提交腾讯" formaction="http://www.qq.com">
</form>
{% endhighlight %}

## Javascript表单验证

首先我们需要讨论一下为什么要需要用到JS表单验证

例如这么一个表单
{% highlight Javascript %}

<form action="www.baidu.com">
	<input type="text" pattern = "/d{1,5}" required autocomplete="on" autofocus="on">
	<input type="submit" value="发送">
</form>
{% endhighlight %}

![shootpic](/assets/img/input-remove.png)

因为浏览器自带可修改代码的功能
(本来是给我们工作人员调试用的)

所以用户可以轻易的通过修改代码，
顽皮的跳过一些重要的数据采集

因此，我们需要在JS代码添加一些
简单的验证

其实用户还能改JS代码，让前端的JS部分失效
所以，前后端对表单的双重验证是必要的常识！
(毕竟用户改不了服务器端的代码嘛)

但是，表单验证不单单验证信息这么简单

比如说你实现一些功能
例如，没有输入直接发送的时候
通过JS的DOM操作弄个非浏览器默认样式的
更加美观的提示框

那么再使用if语句的时候
就需要用到JS表单验证返回的布尔值

还有调试的时候，检验你的正则是否写错啊
表单类型和你输入的值格式是否匹配啊等等

{% highlight Javascript %}

表单一共有11种验证
首先，表单验证都是围绕一个叫validity(英译:有效的、健全的)对象进行的
以下11种验证方法都是validity对象底下的

valid : 独立于其他验证，用来检测其他验证是否通过，
(如果其他验证全部通过，那么valid返回true 否则返回false)

下列属性，如果表单内容不通过则返回true 否则返回false (与valid相反嘛)
badInput : 
valueMissing  :  输入值为空时 返回true
typeMismatch :  控件值与预期类型不匹配时 返回true
patternMismatch  :  输入值不满足pattern正则时 返回true

=== html ===

<form>
	<input type="text" id ="text" pattern = "/d{1,5}" required autocomplete="on" autofocus="on">
	<input type="submit" value="发送">
</form>

=== Javascript === 

window.onload = function()
{
	var oText = document.getElementById("text");
	//这里使用事件监听
	oText.addEventListener("invaild" , fn , flase);
	//阻止下默认事件
	event.preventDefault();
	function fn()
	{
		console.log(oText.validity.valueMissing)
		当啥都没输的时候 弹出true

		console.log(oText.validity.patternMismatch)
		当输入的值 不满足你写的正则函数的时候 返回true

		console.log(oText.validity.typeMismatch)
		当输入的值 和你 表单需要填写的值 类型不同的时候返回true
		比如说input类型是email 但是用户输的值不是一个email
	}	

}


tooLong  :  超过maxLength最大限制时 返回true
rangeUnderflow : 验证的range最小值 
rangeOverflow：验证的range最大值 
stepMismatch: 验证range 的当前值 是否符合min、max及step的规则

(感觉以上4项功能比较鸡肋，因为当你错误的时候浏览器会帮你设置缺省值，也就是说几乎不会有错误的时候
所以这里就不做demo了)

customError 不符合自定义验证
setCustomValidity(); 自定义验证

=== Javascript === 

window.onload = function()
{
	var oText = document.getElementById("text");
	//这里使用事件监听
	oText.addEventListener("invaild" , fn , flase);
	//阻止下默认事件
	event.preventDefault();
	function fn()
	{
		if(this.value == "敏感词汇")
		{
			this.setCustomValidity("嘘，可不能乱填一些带颜色的词语哟");
			//这样可以限制用户的填写
		}
		else
		{
			this.setCustomValidity("");
			//注意 : 当用户没有输入敏感词的时候，一定要把自定义验证清空
			//不然不论用户怎么输入都会弹出自定义的提示信息，也会弹出自定义的验证信息
		}

		//console.log(oText.validity.customError);
		//当用户确实输入了一些敏感的词后 返回true
	}	

}


当有些特殊的时候，暂时不需要验证
比如当用户赶时间的时候，表单没有填写完，需要保存到草稿箱的时候
我们就需要给保存到草稿箱那个submit 按钮添加一个formnovalidate属性来关闭所有的表单验证

{% endhighlight %}

## 新的DOM选择器



### querySelector(类jQuery DOM选择器):

学过JQuery的同学应该比较清楚
在JQ中 获取元素很简单

$('#box') $('.box') $('ol li');

到了HTML5中，DOM 允许我们使用JQ的方法去获取元素


{% highlight Javascript %}

通过获取ID 来获取元素

var oDiv = document.querySeletor('#box');


通过获取类名 来获取元素

var oDiv = document.querySeletor('.box');

但是注意一点
当获取类元素的时候，是不支持两个获取的
也就是说如果有两个DOM结点 都有class="box"
那么querySeletor 无法获取，会返回undefined


通过获取属性名称来获取元素

比如<div tilte="Owen"></div>
我们也可以通过querySeletor获取

var oDiv = document.querySeletor('[title=Owen]');

甚至是自定义属性<div abc="Owen"></div>

var oDiv = document.querySeletor('[abc=Owen]');


获取继承标签组

虽然querySeletor不能获取多个类 的DOM元素
但是可以获取 继承标签组的多个DOM元素
<ul id="ul1">
	<li></li>
	<li></li>
	<li></li>
</ul>

var oLi = document.querySeletor('ul li');
console.log(oLi.length);

或者

你也可以
var oUl1 = document.querySeletor('#ul1');
var oLi = oUl1.querySeletor('li');
console.log(oLi.length);

{% endhighlight %}

### querySeletorAll

{% highlight Javascript %}

上面，我们说到不能通过querySeletor获取多个同类元素
但是我们可以通过querySelectorAll方法来获取多个同类元素


var oDivs = document.querySeletorAll('.box');
console.log(oDivs.length);

同样的
我们也可以使用querySeletorAll()
来获取多个 甚至是自定义的属性

<ul>
	<li abc="Owen" ></li>
	<li></li>
	<li abc="Owen" ></li>
</ul>

var oLi = document.querySelectorAll('[abc=Owen]');
console.log(oLi);

同时也可以获取单个元素(id class)

{% endhighlight %}

| || 是否能识别id || 是否能识别class || 是否能识别多个class || 是否能通过标签选择器识别单个元素 |
|:--------------||:--------------||:--------------||:--------------||:--------------|
| querySelector|| 是 || 是 || 否 || 是 |
|:--------------||:--------------||:--------------||:--------------|:--------------|
| querySelectorAll|| 是 || 是 || 是 || 是 |

`续表:`

| || 是否能识别多个标签组 || 是否能识别单个属性或自定义属性 || 是否能识别多个属性或自定义属性 |
|:--------------||:--------------||:--------------||:--------------|
| querySelector|| 是 || 是 || 是 |
|:--------------||:--------------||:--------------||:--------------|
| querySelectorAll|| 是 || 是 || 是 |

总结来说 使用querySelectorAll 更方便,但是注意querySelectorAll获取元素的时候,都是以数组为单位的
所以，当使用querySelectorAll 获取单个元素的时候 需要加上[0];
var box = document.querySelectorAll("#div")[0];

或者引用的时候再加[0]

var box = document.querySelectorAll("#div");
console.log( box[0] ); 

还有一点需要注意的是，使用querySelectorAll / querySelector来获取HTML5新功能
自定义属性的时候 需要加上data-

<div data-Owen="abc" ></div>
var box = document.querySelectorAll("data-Owen=abc");
而不是 
var box = document.querySelectorAll("Owen=abc");

### getElementsByClassName

类似getElementsByTagName

{% highlight Javascript %}
var oboxs = document.getElementsByClassName('box');
console.log(oboxs);
{% endhighlight %}

### classList

{% highlight Javascript %}
我们可以通过classList来获取到一个元素的全部class

<div id = "box" class="a b c"></div>

var boxClass = document.getElementById('box').classList;
console.log(boxClass);// a b c

注意这里classList 是一个object 类数组 应该说很像json,我们不能同过classList.length++ 
或者 是classList.push()的方法给 这个DOM结点添加类

但是,HTML5给classLIst添加了一些方法来满足我们的需求

length : 属性数量(不能直接改变)
add() : 添加一个类

boxClass.add('d');
console.log(boxClass);

remove() : 删除一个类

boxClass.add('a');
console.log(boxClass);

toggle() : 切换一个类

假设我现在 有 a b c 三个类
如果我执行 boxClass.toggle('a'); 原来类表里面存在,就会删除a这个类
如果我执行 boxClass.toggle('d'); 原来类表里面不存在,就会添加d这个类

{% endhighlight %}

## 自定义属性

我们可以使用data来自定义属性
{% highlight JavaScript %}
如果是HTML5之前
我们这样自定义属性
<div Owen = "abc"></div>
如果要用DOM控制的话就需要用到
getArribute来获取，但是这方法嘛 兼容性不太乐观了

而现在我们可以这样定义属性
<div  data-Owen="abc" data-Owen-Zyz = "cba" ></div>
(注意:这里一定是“ - ”号连接!)
(注意:浏览器在解析的时候,大小写不敏感,也就是说所有含有大写字母的,在解析中都会被变成小写字母)

但是在获取对象的时候,大小写又敏感了,可以获取到DOM

var box = document.querySelector('data-Owen=')
console.log( box.dataset.Owen ); // undefined
console.log( box.dataset.owen ); // abc
console.log( box.dataset.owen-Zyz ) // 报错
console.log( box.dataset.owenZyz ) // cba
console.log( box.dataset.owenzyz ) // undefined
console.log( box.dataset ) // { owen : abc , owenZyz : cba }

实验说明 使用自定义属性的时候一定要注意大小写的问题
或者说我们应该尽量在自定义属性的时候不使用大写
如果说一定要使用大写字母的时候,应先将dataset弹出来看一下具体的属性名
再进行DOM操作

{% endhighlight %}

data这个属性广泛用于jQuery Mobile上
我们只需要添加jQuery Mobile
然后在标签里面配属性就基本可以完成一些手机端的开发
和一些简单的特效
{% highlight html %}

<div data-theme="a" ></div> //把div设置成黑色
{% endhighlight %}

当然除jQuery Mobile 的库
还可以用Knockout 手机端库
[Knockout](http://www.knockoutjs.com)

## defer 和 async

这两个新属性是关于加载脚本的

比如我这里需要加载三个js
{% highlight Javascript %}

<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>

<body>
	...
</body>
{% endhighlight %}

如果,这几个js文件比较大,而碰巧我们可爱的用户网又比较慢
因为默认的加载方式是同步加载[(关于同异步的请参考本站AJAX的有关内容)](http://numerhero.github.io/2015/08/26/AJAX.html)
这时候就会出现一段没有内容的空白期,这样就可能让一些没有耐心的用户停止等待了

defer="defer"属性可以让加载的脚本延迟加载
也就是优先让页面先加载出来,然后再加载一些js功能

而async="async"呢 就是让加载的脚本和页面异步加载,齐头并进
但是,这样就会存在一个问题.加设如果a脚本需要引用b脚本的内容
而a脚本 在 b脚本之前就已经加载完成了,那么在a脚本需要使用b脚本的地方
就会报错了

所以,当我们使用async属性的时候 , 就需要保证加载的几个脚本是互相独立的

## 历史管理

### onhashchange

当我们需要在一个主页面内不断的切换内容(域名只是添加哈希值)也就是一站式页面的时候，应考虑用户需要历史管理的情况
当用户需要前后切换历史内容的时候,缺省的浏览器历史管理方法就无效了
这时候我们就需要调用HTML5中特定的onhashchange方法
{% highlight Javascript %}

demo:

=== html ===

<input type="button" value="随机选择" id="Input">
<br/>
<span id="text"></span>

=== Javascript ===

window.onload = function()
{
	var 
	oInput = document.querySelector("#Input"),
	oText = document.querySelector("#text"),
	json = {};//模拟一个散列表
	
	oInput.onclick = function()
	{
		//随机数模拟产生一个散列值
		var num = Math.random();
		
		var arr = random( 50 , 5 );

		json[num] = arr ; //保存映射关系

		oText.innerHTML = arr;

		window.location.hash = num;//url添加散列值
	}
	
	window.onhashchange = function()
	{
		//通过window.location.hash获取散列值 保证url和散列表的映射关系
		oText.innerHTML = json.[window.location.hash.substring(1)];
	}
	function random(iAll , n)
	{
		一个数组池，从里面抽取n个数
		var arr = [];
		一个数组，用来存放抽取的随机值
		var newArr = [];
		
		压栈iAll个数
		for(var i=1 ; i<iAll ; i++)
		{
			arr.push(i);
		}


		for(var i=0; i<n ; i++)
		{
			从总池中抽取数，因为每次抽取都是出栈，所以将改变随机函数的取值范围，
			所以不会出现无值可取的情况	
			newArr.push( arr.splice(Math.floor(Math.random()*arr.length) , 1 ) );
		}
		return newArr;
	}
}

原理是通过window.location.hash保存散列值,使每一次页面的url都不同,
使浏览器产生历史管理并且保存url和对应的随机数的映射关系,并且通过onhashchange,依据每次url的散列值来修改不同的数据。

{% endhighlight %}

### history新对象

history是HTML5下提供在服务器端下用于保存不同内容的对象
(注意，history只能在服务器端下才能产生作用)

pushState( data , title , url[可选] );
{% highlight Javascript %}
history.pushState方法, 可以将页面的变化状态保存,并自动建立映射关系
参数: 第一个是保存的数据(必须填写) 第二个是保存的页面标题(也是必须填写) 第三个是url(选填)用于
标明页面变化。
{% endhighlight %}

window.onpopstate事件
{% highlight Javascript %}
用来读取对应的历史内容
需要调用事件对象event来调动window.onpopstate底下的state值(也就是保存的页面内容)

demo:
window.onpopstate = function(ev)
{
	var oEvent = event || ev;
	而后调用oEvent.state
}

{% endhighlight %}
{% highlight Javascript %}

来看看再刚才的随机函数的例子:
(html相同,请调整到服务器端测试)

window.onload = function()
{
	var 
	oInput = document.querySelector("#Input"),
	oText = document.querySelector("#text");
	
	oInput.onclick = function()
	{
		
		var arr = random( 50 , 5 );
		history.pushState( arr,'' );    //这里从简,不设置标题和url
		oText.innerHTML = arr;
	}
	
	window.onpopstate = function(ev)
	{
		var oEvent = ev || event
		oText.innerHTML = oEvent.state;
	}
	function random(iAll , n)
	{
		一个数组池，从里面抽取n个数
		var arr = [];
		一个数组，用来存放抽取的随机值
		var newArr = [];
		
		压栈iAll个数
		for(var i=1 ; i<iAll ; i++)
		{
			arr.push(i);
		}


		for(var i=0; i<n ; i++)
		{
			从总池中抽取数，因为每次抽取都是出栈，所以将改变随机函数的取值范围，
			所以不会出现无值可取的情况	
			newArr.push( arr.splice(Math.floor(Math.random()*arr.length) , 1 ) );
		}
		return newArr;
	}
}
{% endhighlight %}

## 拖拽

HTML5支持拖拽
只需要在你需要拖拽的元素标签中添加draggable="true"属性
那么这个元素就可以拖拽了

然后你可以在JS中添加拖拽过程中各个事件
事件的执行顺序:(当 事件drop 不触发,也就是不会在目标元素中添加元素的时候)
dragstart  >  drag >  dragenter >  dragover >  dragleave > dragend 

当事件drop 触发的时候:
dragstart  >  drag >  dragenter >  dragover >  drop > dragend

让我们看看这些事件有什么用处

### ondragstart

当你产生拖拽开始时触发(不是按下的时候)

### ondragend

当你拖住结束的时候触发(鼠标放开的时候)

### ondrag

在拖拽结束的时候触发(不管是否运动,只要你开始拖拽了,拉住的过程中一直都是ondrag)

### ondragenter

当有其他元素拖拽进入的时候触发

### ondragleave

当进入的元素出去的时候触发,(判断触发的标志是鼠标是否离开目标元素而不是被拖拽元素是否超出目标元素)

### ondragover

当进入的元素 存在目标元素内(不放入 与drop相反)

### drop

当进入的元素 存放在目标元素内时触发
( 注意:要想触发drop 一定要在阻止dragover的默认事件ev.preventDefault()才能使drop触发 )

但是,火狐浏览器规定必须设置dataTransfer对象才可以拖拽除图片外的其他标签

### dataTransfer

设置数据传输(一定是字符串)
dataTransfer.setData(key , value) key(是数据下标) value(获取到对应的内容)

dataTransfer.getData(key) 从对象中根据key获取指定格式的元素数据

dataTransfer.clearData(key)
从dataTransfer对象中根据key值删除指定格式的数据，参数可选，若不给出，
则为删除对象中所有的数据。

addElement(element):添加自定义图标

effectAllowed : 当拖拽元素进入目标元素的时候鼠标的光标样式(none, copy, copyLink, copyMove, link, linkMove, move, all 和 uninitialized)

(demo:ev.dataTransfer.effectAllowed = 'copy')

setDragImage(element,x,y):设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向上的距离，y设置图标与鼠标在垂直方向上的距离。

{% highlight Javascript %}
demo:
一个垃圾桶删除功能的demo  垃圾桶可以拖拽

==== html ====
<ul id="ul1">
	<li draggable="true" >a</li>
	<li draggable="true" >s</li>
	<li draggable="true" >c</li>
</ul>

<div draggable="true" id="div1">垃圾桶</div>

==== css ====

#ul1 li{ list-style:none; width:200px; height:30px; background:#ccc; margin-bottom: 5px; border-radius: 5px;}

#div1{ width: 100px; height: 100px; background: red;position: absolute;}

==== Javascript ====

var oUl = document.getElementById('ul1');
	var oLi = oUl.getElementsByTagName('li');
	var oDiv = document.getElementById('div1');

	for(var i = 0 ; i<oLi.length ; i++)
	{
		oLi[i].index = i;
		oLi[i].ondragstart = function(ev)
		{
			var oEvent = ev || event;
			oEvent.dataTransfer.setData( 'Zyz' , this.index );
			this.style.background = 'green';
			oDiv.ondragenter = function()
			{
				this.style.background = 'blue';
			}
		}
		
		oLi[i].ondragend = function()
		{
			this.style.background = 'yellow';
		}
	}

	oDiv.ondragstart = function(ev)
	{
		var oEvent = ev || event;

		var Y = oEvent.clientY - this.offsetTop;
		var X = oEvent.clientX - this.offsetLeft;
		oDiv.ondrag = function(ev)
		{
			var oEvent = ev || event;
			
			var l  = oEvent.clientX - X + 'px';
			var t = oEvent.clientY - Y + 'px';
			this.style.left = l;
			this.style.top = t;
		}
	}
	
	oDiv.ondragend = function(ev)
	{
		var oEvent = ev || event;
	}

	oDiv.ondragleave = function()
	{
		this.style.background = 'red';
	}
	oDiv.ondrop = function(ev)
	{
		var oUl = document.getElementById('ul1');
		//需要进行判断的两点理由

		//要li元素要拖拽的时候才能回setData,如果一开始就拖动垃圾桶会产生错误
		//拖拽目标元素也会触发ondrop事件
		
		if(ev.dataTransfer.getData('Zyz'))
		{
			oUl.removeChild(oLi[ev.dataTransfer.getData('Zyz')]);
			this.style.background = 'black';
		}
		
	}
	

	oDiv.ondragover = function(ev){ev.preventDefault();}

请在chrome下测试,不兼容火狐
{% endhighlight %}



## 感谢

本博文，有相当一部分内容COPY 和 引用了他人的知识，特此陈列，以表感谢

[妙味课堂](www.miaov.com)
[IAN MCNALLY 's blog](http://ianmcnally.me/blog/2015/6/25/input-validity-in-the-html-spec)
[history对象](http://blog.csdn.net/hdchangchang/article/details/41959313)

## 引用出自

### 《javascript高级程序设计》