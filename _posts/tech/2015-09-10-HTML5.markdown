---
layout: post
title: HTML5学习历程
category: 技术
keywords: 技术,HTML5
---
## 写在前页面

关于H5 C3 JS API 的浏览器版本支持度
可以上[caniuse 网站查询](http://caniuse.com/)

## HTML5初始化代码

{% highlight html %}

<！DOCTYPE html>
<html>
<head>
<meta charset="utf-8">	
<title>html5</title>

</head>
<body>
	<header>
		页面头部
	<hgroup>
		定义一组标题组合
		<h1>Owen的博客</h1>
		<h2>仰望星空的天台</h2>
	</hgroup>
	</header>
	<article>
	用来语意化一篇文章主体
		<aside>侧边栏</aside>
		<section>内容区</section>
	</article>
	<footer>页面底部</footer>
</body>
</html>

{% endhighlight %}

比起之前的版本
简化了很多

主要是用于语意化规范
那么语义化规范有什么用呢？

## 语意化标签的作用

### 1.便于SEO爬虫爬取你的页面(SEO优化)

首先，在语意化标签出来之前
我们是通过CSS给标签添加样式之后
(或者id和class稍微的语意化)
才知道每个布局是干什么的

但是搜索引擎(Search Engine)
是看不到我们整个页面的布局的
所以就很难爬取到有用的信息
这样检索信息的时候，你的页面就很难被找到
没被找到基本上你的网站就很难和大众接轨了

所以html标签的语意化有利于SEO找到你页面的关键信息

世界上还举办了这么个节日
[CSS Naked Day](http://baike.baidu.com/link?url=TnnAkTykYvytO7HU7djxxNXaxBInKo5sIF2w6HyeMOpnjhlQM993Fe8jsU1zy9b7A_4HBbBwDbi4iGV6NWhBca)
CSS裸奔节

用以推动Web标准、提倡简洁为美、使用正确的(x)html语义标记、良好的层次结构。

### 2.便于网站维护人员维护页面

其次，如果当公司让你去维护一个不是你自己写的页面
这时候标签是清一色的 div 或者是 td 标签
你这时候就会觉得眼花缭乱 

有可能把作者叫过来看，他自己也忘了啥是啥了
但是如果我们给加的标签自身添加了语义化的功能

我们维护的时候，一看标签就知道是干什么的了
这样工作也会轻松很多

### 3.有利于一些特殊终端的阅读

再来，我们介绍一些计算机的特殊终端:打印机、扫描器、手机等等
如果需要这些特殊的终端设备识别你的页面
标签语义化也是必不可少

## 其他的一些语义化标签

### figure

{% highlight html %}

用于对元素组合
说白了一般就是用来装<img> 和 <video>
figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。
figcation的子元素 用来解释

{% endhighlight %}

### time

用来标记时间
{% highlight html %}
<p>
	庆祝抗日战争胜利70周年,阅兵日<time> 2015-09-03 </time>
</p>

<p>
	我的<time datetime = "1996-03-05">生日</time>
</p>

{% endhighlight %}

### datalist 和 option

选项列表
当你在表单输入时
自动弹出可能值列表
{% highlight html %}

<input type="text" list="valList" />
<datalist id="valList">
 	<option value="javascript">javascript</option>
   <option value="html">html</option>
  <option value="css">css</option>
</datalist>

{% endhighlight %}

这里又引出了一个新的属性"list"
用来关联可能值列表

### summary 和 details

用于列出文档列表
{% highlight html %}
<details>
<summary>点我,就送屠龙宝刀</summary>
乖乖努力打怪升级,自然就有
</details>
{% endhighlight %}

可以加一个属性Open
使列表默认是展开状态

但是，这个标签暂时还只有Chrome 和 Safari 支持

### dialog

这对标签一般用来语意化一段对话
{% highlight html %}

<dialog>
  <dt>老师</dt>
  <dd>2+2 等于？</dd>
  <dt>学生</dt>
  <dd>4</dd>
  <dt>老师</dt>
  <dd>答对了！</dd>
</dialog>
{% endhighlight %}

### address

用来语意化页面作者和他们的详细信息

### mark

高亮某一段需要高亮的字词或是段落
可以在CSS中使用background修改高亮颜色

### keygen

可以使用keygen为发送的表单添加一个公共密钥
{% highlight html %}
<form action="http://numerhero.github.io" method="get">
用户: <input type="text" name="usr_name" />
公钥: <keygen name="security" />
<input type="submit" />
</form>
{% endhighlight %}

### progess

可以定义一个简陋的进度条
{% highlight html %}
<progress max="100" value="77">
     <!-- 这里用以兼容 不支持该标签的浏览器 -->
     <span>77</span>%
</progress>
{% endhighlight %}

## 如何向下兼容IE8以下版本

{% highlight Javascript %}
因为浏览器允许我们自定义标签
比如

<Owen> 每天都萌萌哒 </Owen>

但是自定义的标签没有任何默认样式
需要自己去添加

虽然旧的浏览器版本没有HTML5这些标签
但是我们可以通过JS脚本创建，并给他们添加CSS属性

这里Google开发了一个兼容脚本:

/*! HTML5 Shiv v3.6.1 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed */
;(function(window, document) {
/*jshint evil:true */
  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }
  
    /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/\w+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video',

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

}(this, document));

{% endhighlight %}

只需外部引用一下就能实现兼容了

## 新增的表单属性

### email

{% highlight html %}

<form>
	<input type="email">
	<input type="submit">
</form>

相当于给输入框加了一个正则表达式
用来粗略的区分你输入的是否是一个正确的邮箱地址
(要真正判断 还得配合AJAX)

对于手机端,还会有一个输入法的转换
当你要输入有邮箱的时候,点击email表单
会从其他语言的输入法 转换为英文输入法

{% endhighlight %}

### tel

{% highlight html %}

<form>
	<input type="tel">
	<input type="submit">
</form>

对于PC端，没有什么特殊变化

对于手机端,还会有一个输入法的转换
当你要输入有电话的时候,点击tel表单
会从其他语言的输入法 数字键盘

一些可选属性：
maxlength : 限制最大值
readonly : 默认只读不可修改
size : 输入数字大小
placeholder : 默认提示
dirname : 
{% endhighlight %}

### url

{% highlight html %}

<form>
	<input type="url">
	<input type="submit">
</form>

和email一样
相当于给输入框加了一个正则表达式
用来粗略的区分你输入的是否是一个网址

对于手机端,还会有一个输入法的转换
当你要输入有网址的时候,点击url表单
会从其他语言的输入法 转换为英文输入法

{% endhighlight %}

### search

{% highlight html %}

<form>
	<input type="search">
	<input type="submit">
</form>

搜索框属性
当你输入的时候，
会出现清空内容的按钮
可以配合其他属性使用

{% endhighlight %}

### range

{% highlight html %}

<form>
	<input type="range">
	<input type="submit">
</form>

数值选择器属性
可以用来给我们选择数值
它底下有这么些属性
step : 数值跨度，即每次数值增加量 默认是1
min  : 最小数值
max  : 最大数值
value: 缺省数值值

其中Opera 浏览器 还特意为range 做了数值刻度

{% endhighlight %}

### number

{% highlight html %}

<form>
	<input type="number">
	<input type="submit">
</form>



另外一个数值选择器属性
也可以用来给我们选择数值
它底下也有这么些属性
step : 数值跨度，即每次数值增加量 默认是1
min  : 最小数值
max  : 最大数值
value: 缺省数值值
{% endhighlight %}

### color

{% highlight html %}

可以供我们使用的一个调色板插件
<form>
	<input type="color" id="incolor" >
</form>

可以添加的值
disabled : 是否可用
autocomplete ：弹出自动候选色(和datalist用的时候使用)
autofocus : 是否获取焦点
list : 关联datalist列表 可以给用户产生候选颜色
value : 缺省色

=== Javascript 简单调用 ===

window.onload = function()
{
	var InputColor = document.getElementById('incolor');
	//使用oninput对象调用
	InputColor.oninput = function()
	{
		document.body.style.backgroundColor = this.value;
	}
}
{% endhighlight %}

### date

{% highlight html %}

<form>
	<input type="date" min="1996-03-05" max="2004-09-22">
</form>

一个插入日期的控件

一些可选属性
min : 最小日期
max : 最大日期
{% endhighlight %}

### datatime-local

{% highlight html %}

用法和date差不多
用于选取本地时间
<form>
	<input type="datetime-local" >
</form>

但是貌似没有min 和 max 属性
{% endhighlight %}

### time、week、month

data可以向下细分为

time : 只显示时间
week : 只显示星期
month: 只显示月

## 一些表单的属性

placeholder : 提示信息

autocomplete : 历史输入信息 (on / off)
autofocus : 打开页面自动获取表单焦点 直接加(例子如下)
require : 强制用户填写拥有该属性的表单 直接加(注意:这里直接加的话写的是required 多个d)

pattern : 简单的表单正则表达式(列如：pattern="\d{1,5}" 限制表单中只能填入1-5个数字)
(注意:由于require 和 pattern 是写在行间的属性，所以使用浏览器的修改功能 可以被用户轻易的破除)

formaction : 用来添加一个新的提交路径
formnovalidate : 关闭验证，直接提交
{% highlight html %}

<form action="http://www.baidu.com">
	<input type="text" placeholder="输入的内容"  pattern="\d{1,5}" autofocus required  autocomplete="off">
	<input type="submit" value="提交百度">
	<input type="submit" value="提交腾讯" formaction="http://www.qq.com">
</form>
{% endhighlight %}

## Javascript表单验证

首先我们需要讨论一下为什么要需要用到JS表单验证

例如这么一个表单
{% highlight Javascript %}

<form action="www.baidu.com">
	<input type="text" pattern = "/d{1,5}" required autocomplete="on" autofocus="on">
	<input type="submit" value="发送">
</form>
{% endhighlight %}

![shootpic](/assets/img/input-remove.png)

因为浏览器自带可修改代码的功能
(本来是给我们工作人员调试用的)

所以用户可以轻易的通过修改代码，
顽皮的跳过一些重要的数据采集

因此，我们需要在JS代码添加一些
简单的验证

其实用户还能改JS代码，让前端的JS部分失效
所以，前后端对表单的双重验证是必要的常识！
(毕竟用户改不了服务器端的代码嘛)

但是，表单验证不单单验证信息这么简单

比如说你实现一些功能
例如，没有输入直接发送的时候
通过JS的DOM操作弄个非浏览器默认样式的
更加美观的提示框

那么再使用if语句的时候
就需要用到JS表单验证返回的布尔值

还有调试的时候，检验你的正则是否写错啊
表单类型和你输入的值格式是否匹配啊等等

{% highlight Javascript %}

表单一共有11种验证
首先，表单验证都是围绕一个叫validity(英译:有效的、健全的)对象进行的
以下11种验证方法都是validity对象底下的

valid : 独立于其他验证，用来检测其他验证是否通过，
(如果其他验证全部通过，那么valid返回true 否则返回false)

下列属性，如果表单内容不通过则返回true 否则返回false (与valid相反嘛)
badInput : 
valueMissing  :  输入值为空时 返回true
typeMismatch :  控件值与预期类型不匹配时 返回true
patternMismatch  :  输入值不满足pattern正则时 返回true

=== html ===

<form>
	<input type="text" id ="text" pattern = "/d{1,5}" required autocomplete="on" autofocus="on">
	<input type="submit" value="发送">
</form>

=== Javascript === 

window.onload = function()
{
	var oText = document.getElementById("text");
	//这里使用事件监听
	oText.addEventListener("invaild" , fn , flase);
	//阻止下默认事件
	event.preventDefault();
	function fn()
	{
		console.log(oText.validity.valueMissing)
		当啥都没输的时候 弹出true

		console.log(oText.validity.patternMismatch)
		当输入的值 不满足你写的正则函数的时候 返回true

		console.log(oText.validity.typeMismatch)
		当输入的值 和你 表单需要填写的值 类型不同的时候返回true
		比如说input类型是email 但是用户输的值不是一个email
	}	

}


tooLong  :  超过maxLength最大限制时 返回true
rangeUnderflow : 验证的range最小值 
rangeOverflow：验证的range最大值 
stepMismatch: 验证range 的当前值 是否符合min、max及step的规则

(感觉以上4项功能比较鸡肋，因为当你错误的时候浏览器会帮你设置缺省值，也就是说几乎不会有错误的时候
所以这里就不做demo了)

customError 不符合自定义验证
setCustomValidity(); 自定义验证

=== Javascript === 

window.onload = function()
{
	var oText = document.getElementById("text");
	//这里使用事件监听
	oText.addEventListener("invaild" , fn , flase);
	//阻止下默认事件
	event.preventDefault();
	function fn()
	{
		if(this.value == "敏感词汇")
		{
			this.setCustomValidity("嘘，可不能乱填一些带颜色的词语哟");
			//这样可以限制用户的填写
		}
		else
		{
			this.setCustomValidity("");
			//注意 : 当用户没有输入敏感词的时候，一定要把自定义验证清空
			//不然不论用户怎么输入都会弹出自定义的提示信息，也会弹出自定义的验证信息
		}

		//console.log(oText.validity.customError);
		//当用户确实输入了一些敏感的词后 返回true
	}	

}


当有些特殊的时候，暂时不需要验证
比如当用户赶时间的时候，表单没有填写完，需要保存到草稿箱的时候
我们就需要给保存到草稿箱那个submit 按钮添加一个formnovalidate属性来关闭所有的表单验证

{% endhighlight %}

## 新的DOM选择器



### querySelector(类jQuery DOM选择器):

学过JQuery的同学应该比较清楚
在JQ中 获取元素很简单

$('#box') $('.box') $('ol li');

到了HTML5中，DOM 允许我们使用JQ的方法去获取元素


{% highlight Javascript %}

通过获取ID 来获取元素

var oDiv = document.querySeletor('#box');


通过获取类名 来获取元素

var oDiv = document.querySeletor('.box');

但是注意一点
当获取类元素的时候，是不支持两个获取的
也就是说如果有两个DOM结点 都有class="box"
那么querySeletor 无法获取，会返回undefined


通过获取属性名称来获取元素

比如<div tilte="Owen"></div>
我们也可以通过querySeletor获取

var oDiv = document.querySeletor('[title=Owen]');

甚至是自定义属性<div abc="Owen"></div>

var oDiv = document.querySeletor('[abc=Owen]');


获取继承标签组

虽然querySeletor不能获取多个类 的DOM元素
但是可以获取 继承标签组的多个DOM元素
<ul id="ul1">
	<li></li>
	<li></li>
	<li></li>
</ul>

var oLi = document.querySeletor('ul li');
console.log(oLi.length);

或者

你也可以
var oUl1 = document.querySeletor('#ul1');
var oLi = oUl1.querySeletor('li');
console.log(oLi.length);

{% endhighlight %}

### querySeletorAll

{% highlight Javascript %}

上面，我们说到不能通过querySeletor获取多个同类元素
但是我们可以通过querySelectorAll方法来获取多个同类元素


var oDivs = document.querySeletorAll('.box');
console.log(oDivs.length);

同样的
我们也可以使用querySeletorAll()
来获取多个 甚至是自定义的属性

<ul>
	<li abc="Owen" ></li>
	<li></li>
	<li abc="Owen" ></li>
</ul>

var oLi = document.querySelectorAll('[abc=Owen]');
console.log(oLi);

同时也可以获取单个元素(id class)

{% endhighlight %}

| || 是否能识别id || 是否能识别class || 是否能识别多个class || 是否能通过标签选择器识别单个元素 |
|:--------------||:--------------||:--------------||:--------------||:--------------|
| querySelector|| 是 || 是 || 否 || 是 |
|:--------------||:--------------||:--------------||:--------------|:--------------|
| querySelectorAll|| 是 || 是 || 是 || 是 |

`续表:`

| || 是否能识别多个标签组 || 是否能识别单个属性或自定义属性 || 是否能识别多个属性或自定义属性 |
|:--------------||:--------------||:--------------||:--------------|
| querySelector|| 是 || 是 || 是 |
|:--------------||:--------------||:--------------||:--------------|
| querySelectorAll|| 是 || 是 || 是 |

总结来说 使用querySelectorAll 更方便

======= 华丽丽的分界线 =======

### getElementsByClassName

类似getElementsByTagName

{% highlight Javascript %}
var oboxs = document.getElementsByClassName('box');
console.log(oboxs);
{% endhighlight %}

### classList

{% highlight Javascript %}
我们可以通过classList来获取到一个元素的全部class

<div id = "box" class="a b c"></div>

var boxClass = document.getElementById('box').classList;
console.log(boxClass);// a b c

注意这里classList 是一个object 类数组 应该说很像json,我们不能同过classList.length++ 
或者 是classList.push()的方法给 这个DOM结点添加类

但是,HTML5给classLIst添加了一些方法来满足我们的需求

length : 属性数量(不能直接改变)
add() : 添加一个类

boxClass.add('d');
console.log(boxClass);

remove() : 删除一个类

boxClass.add('a');
console.log(boxClass);

toggle() : 切换一个类

假设我现在 有 a b c 三个类
如果我执行 boxClass.toggle('a'); 原来类表里面存在,就会删除a这个类
如果我执行 boxClass.toggle('d'); 原来类表里面不存在,就会添加d这个类

{% endhighlight %}

## 感谢

本博文，有相当一部分内容COPY 和 引用了他人的知识，特此陈列，以表感谢

[妙味课堂](www.miaov.com)
[IAN MCNALLY 's blog](http://ianmcnally.me/blog/2015/6/25/input-validity-in-the-html-spec)
## 引用出自

### 《javascript高级程序设计》