---
layout: post
title: HTML5学习历程
category: 技术
keywords: 技术,HTML5
---
## 写在前页面

关于H5 C3 JS API 的浏览器版本支持度
可以上[caniuse 网站查询](http://caniuse.com/)

## HTML5初始化代码

{% highlight html %}

<！DOCTYPE html>
<html>
<head>
<meta charset="utf-8">	
<title>html5</title>

</head>
<body>
	<header>
		页面头部
	<hgroup>
		定义一组标题组合
		<h1>Owen的博客</h1>
		<h2>仰望星空的天台</h2>
	</hgroup>
	</header>
	<article>
	用来语意化一篇文章主体
		<aside>侧边栏</aside>
		<section>内容区</section>
	</article>
	<footer>页面底部</footer>
</body>
</html>

{% endhighlight %}

比起之前的版本
简化了很多

主要是用于语意化规范
那么语义化规范有什么用呢？

## 语意化标签的作用

### 1.便于SEO爬虫爬取你的页面(SEO优化)

首先，在语意化标签出来之前
我们是通过CSS给标签添加样式之后
(或者id和class稍微的语意化)
才知道每个布局是干什么的

但是搜索引擎(Search Engine)
是看不到我们整个页面的布局的
所以就很难爬取到有用的信息
这样检索信息的时候，你的页面就很难被找到
没被找到基本上你的网站就很难和大众接轨了

所以html标签的语意化有利于SEO找到你页面的关键信息

世界上还举办了这么个节日
[CSS Naked Day](http://baike.baidu.com/link?url=TnnAkTykYvytO7HU7djxxNXaxBInKo5sIF2w6HyeMOpnjhlQM993Fe8jsU1zy9b7A_4HBbBwDbi4iGV6NWhBca)
CSS裸奔节

用以推动Web标准、提倡简洁为美、使用正确的(x)html语义标记、良好的层次结构。

### 2.便于网站维护人员维护页面

其次，如果当公司让你去维护一个不是你自己写的页面
这时候标签是清一色的 div 或者是 td 标签
你这时候就会觉得眼花缭乱 

有可能把作者叫过来看，他自己也忘了啥是啥了
但是如果我们给加的标签自身添加了语义化的功能

我们维护的时候，一看标签就知道是干什么的了
这样工作也会轻松很多

### 3.有利于一些特殊终端的阅读

再来，我们介绍一些计算机的特殊终端:打印机、扫描器、手机等等
如果需要这些特殊的终端设备识别你的页面
标签语义化也是必不可少

## 其他的一些语义化标签

### figure

{% highlight html %}

用于对元素组合
说白了一般就是用来装<img> 和 <video>
figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。
figcation的子元素 用来解释

{% endhighlight %}

### time

用来标记时间
{% highlight html %}
<p>
	庆祝抗日战争胜利70周年,阅兵日<time> 2015-09-03 </time>
</p>

<p>
	我的<time datetime = "1996-03-05">生日</time>
</p>

{% endhighlight %}

### datalist 和 option

选项列表
当你在表单输入时
自动弹出可能值列表
{% highlight html %}

<input type="text" list="valList" />
<datalist id="valList">
 	<option value="javascript">javascript</option>
   <option value="html">html</option>
  <option value="css">css</option>
</datalist>

{% endhighlight %}

这里又引出了一个新的属性"list"
用来关联可能值列表

### summary 和 details

用于列出文档列表
{% highlight html %}
<details>
<summary>点我,就送屠龙宝刀</summary>
乖乖努力打怪升级,自然就有
</details>
{% endhighlight %}

可以加一个属性Open
使列表默认是展开状态

但是，这个标签暂时还只有Chrome 和 Safari 支持

### dialog

这对标签一般用来语意化一段对话
{% highlight html %}

<dialog>
  <dt>老师</dt>
  <dd>2+2 等于？</dd>
  <dt>学生</dt>
  <dd>4</dd>
  <dt>老师</dt>
  <dd>答对了！</dd>
</dialog>
{% endhighlight %}

### address

用来语意化页面作者和他们的详细信息

### mark

高亮某一段需要高亮的字词或是段落
可以在CSS中使用background修改高亮颜色

### keygen

可以使用keygen为发送的表单添加一个公共密钥
{% highlight html %}
<form action="http://numerhero.github.io" method="get">
用户: <input type="text" name="usr_name" />
公钥: <keygen name="security" />
<input type="submit" />
</form>
{% endhighlight %}

### progess

可以定义一个简陋的进度条
{% highlight html %}
<progress max="100" value="77">
     <!-- 这里用以兼容 不支持该标签的浏览器 -->
     <span>77</span>%
</progress>
{% endhighlight %}

## 如何向下兼容IE8以下版本

{% highlight Javascript %}
因为浏览器允许我们自定义标签
比如

<Owen> 每天都萌萌哒 </Owen>

但是自定义的标签没有任何默认样式
需要自己去添加

虽然旧的浏览器版本没有HTML5这些标签
但是我们可以通过JS脚本创建，并给他们添加CSS属性

这里Google开发了一个兼容脚本:

{% endhighlight %}

<a href="javascript:" data-download = "/assets/download/html5shiv.js" class="download">点击下载html5shiv</a>

只需外部引用一下就能实现兼容了

## 新增的表单属性

### email

{% highlight html %}

<form>
	<input type="email">
	<input type="submit">
</form>

相当于给输入框加了一个正则表达式
用来粗略的区分你输入的是否是一个正确的邮箱地址
(要真正判断 还得配合AJAX)

对于手机端,还会有一个输入法的转换
当你要输入有邮箱的时候,点击email表单
会从其他语言的输入法 转换为英文输入法

{% endhighlight %}

### tel

{% highlight html %}

<form>
	<input type="tel">
	<input type="submit">
</form>

对于PC端，没有什么特殊变化

对于手机端,还会有一个输入法的转换
当你要输入有电话的时候,点击tel表单
会从其他语言的输入法 数字键盘

一些可选属性：
maxlength : 限制最大值
readonly : 默认只读不可修改
size : 输入数字大小
placeholder : 默认提示
dirname : 
{% endhighlight %}

### url

{% highlight html %}

<form>
	<input type="url">
	<input type="submit">
</form>

和email一样
相当于给输入框加了一个正则表达式
用来粗略的区分你输入的是否是一个网址

对于手机端,还会有一个输入法的转换
当你要输入有网址的时候,点击url表单
会从其他语言的输入法 转换为英文输入法

{% endhighlight %}

### search

{% highlight html %}

<form>
	<input type="search">
	<input type="submit">
</form>

搜索框属性
当你输入的时候，
会出现清空内容的按钮
可以配合其他属性使用

{% endhighlight %}

### range

{% highlight html %}

<form>
	<input type="range">
	<input type="submit">
</form>

数值选择器属性
可以用来给我们选择数值
它底下有这么些属性
step : 数值跨度，即每次数值增加量 默认是1
min  : 最小数值
max  : 最大数值
value: 缺省数值值

其中Opera 浏览器 还特意为range 做了数值刻度

{% endhighlight %}

### number

{% highlight html %}

<form>
	<input type="number">
	<input type="submit">
</form>



另外一个数值选择器属性
也可以用来给我们选择数值
它底下也有这么些属性
step : 数值跨度，即每次数值增加量 默认是1
min  : 最小数值
max  : 最大数值
value: 缺省数值值
{% endhighlight %}

### color

{% highlight html %}

可以供我们使用的一个调色板插件
<form>
	<input type="color" id="incolor" >
</form>

可以添加的值
disabled : 是否可用
autocomplete ：弹出自动候选色(和datalist用的时候使用)
autofocus : 是否获取焦点
list : 关联datalist列表 可以给用户产生候选颜色
value : 缺省色

=== Javascript 简单调用 ===

window.onload = function()
{
	var InputColor = document.getElementById('incolor');
	//使用oninput对象调用
	InputColor.oninput = function()
	{
		document.body.style.backgroundColor = this.value;
	}
}
{% endhighlight %}

### date

{% highlight html %}

<form>
	<input type="date" min="1996-03-05" max="2004-09-22">
</form>

一个插入日期的控件

一些可选属性
min : 最小日期
max : 最大日期
{% endhighlight %}

### datatime-local

{% highlight html %}

用法和date差不多
用于选取本地时间
<form>
	<input type="datetime-local" >
</form>

但是貌似没有min 和 max 属性
{% endhighlight %}

### time、week、month

data可以向下细分为

time : 只显示时间
week : 只显示星期
month: 只显示月

## 一些表单的属性

placeholder : 提示信息

autocomplete : 历史输入信息 (on / off)
autofocus : 打开页面自动获取表单焦点 直接加(例子如下)
require : 强制用户填写拥有该属性的表单 直接加(注意:这里直接加的话写的是required 多个d)

pattern : 简单的表单正则表达式(列如：pattern="\d{1,5}" 限制表单中只能填入1-5个数字)
(注意:由于require 和 pattern 是写在行间的属性，所以使用浏览器的修改功能 可以被用户轻易的破除)

formaction : 用来添加一个新的提交路径
formnovalidate : 关闭验证，直接提交
{% highlight html %}

<form action="http://www.baidu.com">
	<input type="text" placeholder="输入的内容"  pattern="\d{1,5}" autofocus required  autocomplete="off">
	<input type="submit" value="提交百度">
	<input type="submit" value="提交腾讯" formaction="http://www.qq.com">
</form>
{% endhighlight %}

## Javascript表单验证

首先我们需要讨论一下为什么要需要用到JS表单验证

例如这么一个表单
{% highlight Javascript %}

<form action="www.baidu.com">
	<input type="text" pattern = "/d{1,5}" required autocomplete="on" autofocus="on">
	<input type="submit" value="发送">
</form>
{% endhighlight %}

![shootpic](/assets/img/input-remove.png)

因为浏览器自带可修改代码的功能
(本来是给我们工作人员调试用的)

所以用户可以轻易的通过修改代码，
顽皮的跳过一些重要的数据采集

因此，我们需要在JS代码添加一些
简单的验证

其实用户还能改JS代码，让前端的JS部分失效
所以，前后端对表单的双重验证是必要的常识！
(毕竟用户改不了服务器端的代码嘛)

但是，表单验证不单单验证信息这么简单

比如说你实现一些功能
例如，没有输入直接发送的时候
通过JS的DOM操作弄个非浏览器默认样式的
更加美观的提示框

那么再使用if语句的时候
就需要用到JS表单验证返回的布尔值

还有调试的时候，检验你的正则是否写错啊
表单类型和你输入的值格式是否匹配啊等等

{% highlight Javascript %}

表单一共有11种验证
首先，表单验证都是围绕一个叫validity(英译:有效的、健全的)对象进行的
以下11种验证方法都是validity对象底下的

valid : 独立于其他验证，用来检测其他验证是否通过，
(如果其他验证全部通过，那么valid返回true 否则返回false)

下列属性，如果表单内容不通过则返回true 否则返回false (与valid相反嘛)
badInput : 
valueMissing  :  输入值为空时 返回true
typeMismatch :  控件值与预期类型不匹配时 返回true
patternMismatch  :  输入值不满足pattern正则时 返回true

=== html ===

<form>
	<input type="text" id ="text" pattern = "/d{1,5}" required autocomplete="on" autofocus="on">
	<input type="submit" value="发送">
</form>

=== Javascript === 

window.onload = function()
{
	var oText = document.getElementById("text");
	//这里使用事件监听
	oText.addEventListener("invaild" , fn , flase);
	//阻止下默认事件
	event.preventDefault();
	function fn()
	{
		console.log(oText.validity.valueMissing)
		当啥都没输的时候 弹出true

		console.log(oText.validity.patternMismatch)
		当输入的值 不满足你写的正则函数的时候 返回true

		console.log(oText.validity.typeMismatch)
		当输入的值 和你 表单需要填写的值 类型不同的时候返回true
		比如说input类型是email 但是用户输的值不是一个email
	}	

}


tooLong  :  超过maxLength最大限制时 返回true
rangeUnderflow : 验证的range最小值 
rangeOverflow：验证的range最大值 
stepMismatch: 验证range 的当前值 是否符合min、max及step的规则

(感觉以上4项功能比较鸡肋，因为当你错误的时候浏览器会帮你设置缺省值，也就是说几乎不会有错误的时候
所以这里就不做demo了)

customError 不符合自定义验证
setCustomValidity(); 自定义验证

=== Javascript === 

window.onload = function()
{
	var oText = document.getElementById("text");
	//这里使用事件监听
	oText.addEventListener("invaild" , fn , flase);
	//阻止下默认事件
	event.preventDefault();
	function fn()
	{
		if(this.value == "敏感词汇")
		{
			this.setCustomValidity("嘘，可不能乱填一些带颜色的词语哟");
			//这样可以限制用户的填写
		}
		else
		{
			this.setCustomValidity("");
			//注意 : 当用户没有输入敏感词的时候，一定要把自定义验证清空
			//不然不论用户怎么输入都会弹出自定义的提示信息，也会弹出自定义的验证信息
		}

		//console.log(oText.validity.customError);
		//当用户确实输入了一些敏感的词后 返回true
	}	

}


当有些特殊的时候，暂时不需要验证
比如当用户赶时间的时候，表单没有填写完，需要保存到草稿箱的时候
我们就需要给保存到草稿箱那个submit 按钮添加一个formnovalidate属性来关闭所有的表单验证

{% endhighlight %}

## 新的DOM选择器



### querySelector(类jQuery DOM选择器):

学过JQuery的同学应该比较清楚
在JQ中 获取元素很简单

$('#box') $('.box') $('ol li');

到了HTML5中，DOM 允许我们使用JQ的方法去获取元素


{% highlight Javascript %}

通过获取ID 来获取元素

var oDiv = document.querySeletor('#box');


通过获取类名 来获取元素

var oDiv = document.querySeletor('.box');

但是注意一点
当获取类元素的时候，是不支持两个获取的
也就是说如果有两个DOM结点 都有class="box"
那么querySeletor 无法获取，会返回undefined


通过获取属性名称来获取元素

比如<div tilte="Owen"></div>
我们也可以通过querySeletor获取

var oDiv = document.querySeletor('[title=Owen]');

甚至是自定义属性<div abc="Owen"></div>

var oDiv = document.querySeletor('[abc=Owen]');


获取继承标签组

虽然querySeletor不能获取多个类 的DOM元素
但是可以获取 继承标签组的多个DOM元素
<ul id="ul1">
	<li></li>
	<li></li>
	<li></li>
</ul>

var oLi = document.querySeletor('ul li');
console.log(oLi.length);

或者

你也可以
var oUl1 = document.querySeletor('#ul1');
var oLi = oUl1.querySeletor('li');
console.log(oLi.length);

{% endhighlight %}

### querySeletorAll

{% highlight Javascript %}

上面，我们说到不能通过querySeletor获取多个同类元素
但是我们可以通过querySelectorAll方法来获取多个同类元素


var oDivs = document.querySeletorAll('.box');
console.log(oDivs.length);

同样的
我们也可以使用querySeletorAll()
来获取多个 甚至是自定义的属性

<ul>
	<li abc="Owen" ></li>
	<li></li>
	<li abc="Owen" ></li>
</ul>

var oLi = document.querySelectorAll('[abc=Owen]');
console.log(oLi);

同时也可以获取单个元素(id class)

{% endhighlight %}

| || 是否能识别id || 是否能识别class || 是否能识别多个class || 是否能通过标签选择器识别单个元素 |
|:--------------||:--------------||:--------------||:--------------||:--------------|
| querySelector|| 是 || 是 || 否 || 是 |
|:--------------||:--------------||:--------------||:--------------|:--------------|
| querySelectorAll|| 是 || 是 || 是 || 是 |

`续表:`

| || 是否能识别多个标签组 || 是否能识别单个属性或自定义属性 || 是否能识别多个属性或自定义属性 |
|:--------------||:--------------||:--------------||:--------------|
| querySelector|| 是 || 是 || 是 |
|:--------------||:--------------||:--------------||:--------------|
| querySelectorAll|| 是 || 是 || 是 |

总结来说 使用querySelectorAll 更方便,但是注意querySelectorAll获取元素的时候,都是以数组为单位的
所以，当使用querySelectorAll 获取单个元素的时候 需要加上[0];
var box = document.querySelectorAll("#div")[0];

或者引用的时候再加[0]

var box = document.querySelectorAll("#div");
console.log( box[0] ); 

还有一点需要注意的是，使用querySelectorAll / querySelector来获取HTML5新功能
自定义属性的时候 需要加上data-

<div data-Owen="abc" ></div>
var box = document.querySelectorAll("data-Owen=abc");
而不是 
var box = document.querySelectorAll("Owen=abc");

### getElementsByClassName

类似getElementsByTagName

{% highlight Javascript %}
var oboxs = document.getElementsByClassName('box');
console.log(oboxs);
{% endhighlight %}

### classList

{% highlight Javascript %}
我们可以通过classList来获取到一个元素的全部class

<div id = "box" class="a b c"></div>

var boxClass = document.getElementById('box').classList;
console.log(boxClass);// a b c

注意这里classList 是一个object 类数组 应该说很像json,我们不能同过classList.length++ 
或者 是classList.push()的方法给 这个DOM结点添加类

但是,HTML5给classLIst添加了一些方法来满足我们的需求

length : 属性数量(不能直接改变)
add() : 添加一个类

boxClass.add('d');
console.log(boxClass);

remove() : 删除一个类

boxClass.add('a');
console.log(boxClass);

toggle() : 切换一个类

假设我现在 有 a b c 三个类
如果我执行 boxClass.toggle('a'); 原来类表里面存在,就会删除a这个类
如果我执行 boxClass.toggle('d'); 原来类表里面不存在,就会添加d这个类

{% endhighlight %}

## 自定义属性

我们可以使用data来自定义属性
{% highlight JavaScript %}
如果是HTML5之前
我们这样自定义属性
<div Owen = "abc"></div>
如果要用DOM控制的话就需要用到
getArribute来获取，但是这方法嘛 兼容性不太乐观了

而现在我们可以这样定义属性
<div  data-Owen="abc" data-Owen-Zyz = "cba" ></div>
(注意:这里一定是“ - ”号连接!)
(注意:浏览器在解析的时候,大小写不敏感,也就是说所有含有大写字母的,在解析中都会被变成小写字母)

但是在获取对象的时候,大小写又敏感了,可以获取到DOM

var box = document.querySelector('data-Owen=')
console.log( box.dataset.Owen ); // undefined
console.log( box.dataset.owen ); // abc
console.log( box.dataset.owen-Zyz ) // 报错
console.log( box.dataset.owenZyz ) // cba
console.log( box.dataset.owenzyz ) // undefined
console.log( box.dataset ) // { owen : abc , owenZyz : cba }

实验说明 使用自定义属性的时候一定要注意大小写的问题
或者说我们应该尽量在自定义属性的时候不使用大写
如果说一定要使用大写字母的时候,应先将dataset弹出来看一下具体的属性名
再进行DOM操作:

var obj = document.querySelectorAll('[data-Owen]');
console.log(obj.getAttribute('data-Owen'));//abc

通过getAttribute方法我们就可以利用html中传递过来的内容了

{% endhighlight %}

data这个属性广泛用于jQuery Mobile上
我们只需要添加jQuery Mobile
然后在标签里面配属性就基本可以完成一些手机端的开发
和一些简单的特效
{% highlight html %}

<div data-theme="a" ></div> //把div设置成黑色
{% endhighlight %}

当然除jQuery Mobile 的库
还可以用Knockout 手机端库
[Knockout](http://www.knockoutjs.com)

## defer 和 async

这两个新属性是关于加载脚本的

比如我这里需要加载三个js
{% highlight Javascript %}

<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>

<body>
	...
</body>
{% endhighlight %}

如果,这几个js文件比较大,而碰巧我们可爱的用户网又比较慢
因为默认的加载方式是同步加载[(关于同异步的请参考本站AJAX的有关内容)](http://numerhero.github.io/2015/08/26/AJAX.html)
这时候就会出现一段没有内容的空白期,这样就可能让一些没有耐心的用户停止等待了

defer="defer"属性可以让加载的脚本延迟加载
也就是优先让页面先加载出来,然后再加载一些js功能

而async="async"呢 就是让加载的脚本和页面异步加载,齐头并进
但是,这样就会存在一个问题.加设如果a脚本需要引用b脚本的内容
而a脚本 在 b脚本之前就已经加载完成了,那么在a脚本需要使用b脚本的地方
就会报错了

所以,当我们使用async属性的时候 , 就需要保证加载的几个脚本是互相独立的

## 历史管理

### onhashchange

当我们需要在一个主页面内不断的切换内容(域名只是添加哈希值)也就是一站式页面的时候，应考虑用户需要历史管理的情况
当用户需要前后切换历史内容的时候,缺省的浏览器历史管理方法就无效了
这时候我们就需要调用HTML5中特定的onhashchange方法
{% highlight Javascript %}

demo:

=== html ===

<input type="button" value="随机选择" id="Input">
<br/>
<span id="text"></span>

=== Javascript ===

window.onload = function()
{
	var 
	oInput = document.querySelector("#Input"),
	oText = document.querySelector("#text"),
	json = {};//模拟一个散列表
	
	oInput.onclick = function()
	{
		//随机数模拟产生一个散列值
		var num = Math.random();
		
		var arr = random( 50 , 5 );

		json[num] = arr ; //保存映射关系

		oText.innerHTML = arr;

		window.location.hash = num;//url添加散列值
	}
	
	window.onhashchange = function()
	{
		//通过window.location.hash获取散列值 保证url和散列表的映射关系
		oText.innerHTML = json.[window.location.hash.substring(1)];
	}
	function random(iAll , n)
	{
		一个数组池，从里面抽取n个数
		var arr = [];
		一个数组，用来存放抽取的随机值
		var newArr = [];
		
		压栈iAll个数
		for(var i=1 ; i<iAll ; i++)
		{
			arr.push(i);
		}


		for(var i=0; i<n ; i++)
		{
			从总池中抽取数，因为每次抽取都是出栈，所以将改变随机函数的取值范围，
			所以不会出现无值可取的情况	
			newArr.push( arr.splice(Math.floor(Math.random()*arr.length) , 1 ) );
		}
		return newArr;
	}
}

原理是通过window.location.hash保存散列值,使每一次页面的url都不同,
使浏览器产生历史管理并且保存url和对应的随机数的映射关系,并且通过onhashchange,依据每次url的散列值来修改不同的数据。

{% endhighlight %}

### history新对象

history是HTML5下提供在服务器端下用于保存不同内容的对象
(注意，history只能在服务器端下才能产生作用)

pushState( data , title , url[可选] );
{% highlight Javascript %}
history.pushState方法, 可以将页面的变化状态保存,并自动建立映射关系
参数: 第一个是保存的数据(必须填写) 第二个是保存的页面标题(也是必须填写) 第三个是url(选填)用于
标明页面变化。
{% endhighlight %}

window.onpopstate事件
{% highlight Javascript %}
用来读取对应的历史内容
需要调用事件对象event来调动window.onpopstate底下的state值(也就是保存的页面内容)

demo:
window.onpopstate = function(ev)
{
	var oEvent = event || ev;
	而后调用oEvent.state
}

{% endhighlight %}
{% highlight Javascript %}

来看看再刚才的随机函数的例子:
(html相同,请调整到服务器端测试)

window.onload = function()
{
	var 
	oInput = document.querySelector("#Input"),
	oText = document.querySelector("#text");
	
	oInput.onclick = function()
	{
		
		var arr = random( 50 , 5 );
		history.pushState( arr,'' );    //这里从简,不设置标题和url
		oText.innerHTML = arr;
	}
	
	window.onpopstate = function(ev)
	{
		var oEvent = ev || event
		oText.innerHTML = oEvent.state;
	}
	function random(iAll , n)
	{
		一个数组池，从里面抽取n个数
		var arr = [];
		一个数组，用来存放抽取的随机值
		var newArr = [];
		
		压栈iAll个数
		for(var i=1 ; i<iAll ; i++)
		{
			arr.push(i);
		}


		for(var i=0; i<n ; i++)
		{
			从总池中抽取数，因为每次抽取都是出栈，所以将改变随机函数的取值范围，
			所以不会出现无值可取的情况	
			newArr.push( arr.splice(Math.floor(Math.random()*arr.length) , 1 ) );
		}
		return newArr;
	}
}
{% endhighlight %}

## 拖拽

HTML5支持拖拽
只需要在你需要拖拽的元素标签中添加draggable="true"属性
那么这个元素就可以拖拽了

然后你可以在JS中添加拖拽过程中各个事件
事件的执行顺序:(当 事件drop 不触发,也就是不会在目标元素中添加元素的时候)
dragstart  >  drag >  dragenter >  dragover >  dragleave > dragend 

当事件drop 触发的时候:
dragstart  >  drag >  dragenter >  dragover >  drop > dragend

让我们看看这些事件有什么用处

### ondragstart

当你产生拖拽开始时触发(不是按下的时候)

### ondragend

当你拖住结束的时候触发(鼠标放开的时候)

### ondrag

在拖拽结束的时候触发(不管是否运动,只要你开始拖拽了,拉住的过程中一直都是ondrag)

### ondragenter

当有其他元素拖拽进入的时候触发

### ondragleave

当进入的元素出去的时候触发,(判断触发的标志是鼠标是否离开目标元素而不是被拖拽元素是否超出目标元素)

### ondragover

当进入的元素 存在目标元素内(不放入 与drop相反)

### drop

当进入的元素 存放在目标元素内时触发
( 注意:要想触发drop 一定要在阻止dragover的默认事件ev.preventDefault()才能使drop触发 )

但是,火狐浏览器规定必须设置dataTransfer对象才可以拖拽除图片外的其他标签

### dataTransfer

设置数据传输(一定是字符串)
dataTransfer.setData(key , value) key(是数据下标) value(获取到对应的内容)

dataTransfer.getData(key) 从对象中根据key获取指定格式的元素数据

dataTransfer.clearData(key)
从dataTransfer对象中根据key值删除指定格式的数据，参数可选，若不给出，
则为删除对象中所有的数据。

addElement(element):添加自定义图标

effectAllowed : 当拖拽元素进入目标元素的时候鼠标的光标样式(none, copy, copyLink, copyMove, link, linkMove, move, all 和 uninitialized)

(demo:ev.dataTransfer.effectAllowed = 'copy')

setDragImage(element,x,y):设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向上的距离，y设置图标与鼠标在垂直方向上的距离。

{% highlight Javascript %}
demo:
一个垃圾桶删除功能的demo  垃圾桶可以拖拽

==== html ====
<ul id="ul1">
	<li draggable="true" >a</li>
	<li draggable="true" >s</li>
	<li draggable="true" >c</li>
</ul>

<div draggable="true" id="div1">垃圾桶</div>

==== css ====

#ul1 li{ list-style:none; width:200px; height:30px; background:#ccc; margin-bottom: 5px; border-radius: 5px;}

#div1{ width: 100px; height: 100px; background: red;position: absolute;}

==== Javascript ====

var oUl = document.getElementById('ul1');
var oLi = oUl.getElementsByTagName('li');
var oDiv = document.getElementById('div1');

for(var i = 0 ; i<oLi.length ; i++)
{
	oLi[i].index = i;
	oLi[i].ondragstart = function(ev)
	{
		var oEvent = ev || event;
		oEvent.dataTransfer.setData( 'Zyz' , this.index );
		this.style.background = 'green';
		oDiv.ondragenter = function()
		{
			this.style.background = 'blue';
		}
	}
	
	oLi[i].ondragend = function()
	{
		this.style.background = 'yellow';
	}
}

oDiv.ondragstart = function(ev)
{
	var oEvent = ev || event;

	var Y = oEvent.clientY - this.offsetTop;
	var X = oEvent.clientX - this.offsetLeft;
	oDiv.ondrag = function(ev)
	{
		var oEvent = ev || event;
		
		var l  = oEvent.clientX - X + 'px';
		var t = oEvent.clientY - Y + 'px';
		this.style.left = l;
		this.style.top = t;
	}
}

oDiv.ondragend = function(ev)
{
	var oEvent = ev || event;
}

oDiv.ondragleave = function()
{
	this.style.background = 'red';
}

oDiv.ondrop = function(ev)
{
	var oUl = document.getElementById('ul1');
	//需要进行判断的两点理由

	//要li元素要拖拽的时候才能回setData,如果一开始就拖动垃圾桶会产生错误
	//拖拽目标元素也会触发ondrop事件
	
	if(ev.dataTransfer.getData('Zyz'))
	{
		oUl.removeChild(oLi[ev.dataTransfer.getData('Zyz')]);
		this.style.background = 'black';
	}
	
}

oDiv.ondragover = function(ev){ev.preventDefault();}

请在chrome下测试,不兼容火狐
{% endhighlight %}

### file

HTML5允许用户从外部拖拽文件
ev.dataTransfer.files

拖拽进来的文件会被浏览器自动打开,这时候我们只需要阻止ondrop的默认事件就可以了

filesList
单次拖拽进来后会返回一个filesList(对象)列表 列表下 有这么几个属性

{% highlight Javascript %}
name : 文件名(包括后缀)
length : 单次拖拽进来文件的个数 
type : 拖拽进来文件的类型
size : 文件的大小
lastModifiedDate : 该文件的最后修改时间
webkitRelativePath : webkit相关路径

demo:

oDiv.ondrop = function(ev)
{
	var fs = ev.dataTransfer.files;
	console.log(fs[0].type);
	ev.preventDefault();
}
{% endhighlight %}

FileReader对象
{% highlight Javascript %}
当我们接受完文件之后,还需要能读取这些文件
所以,我们需要用到这么一个对象FileReader

FileReader下面有这么几个方法
readAsDataURL([format])读取fileList文件中的数据 format必填,填fileList中的文件
FileReader().onload 加载该文件数据该方法中一个result的值,返回的是文件base64的内容

onloadend
onloadstart
onprogress 


demo:
=== html ===
<div draggable="true" id="div1">将文件拖拽到此区域</div>
<ul id="ul1">

=== css ===
#div1{ width: 200px; height: 200px; background: red; margin: 100px; }
#ul1{ list-style: none;}

=== javascript ===
window.onload = function()
{

	var oDiv = document.getElementById('div1');
	var oUl  = document.getElementById('ul1');

	oDiv.ondragenter = function()
	{
		this.innerHTML = '可以释放鼠标';
		this.style.background = 'blue';
	}

	oDiv.ondragover = function(ev)
	{
		ev.preventDefault();
	}

	oDiv.ondragleave = function()
	{
		this.innerHTML = '将文件拖拽到此区域'
		this.style.background = 'red';
	}

	oDiv.ondrop = function(ev)
	{
		ev.preventDefault();
		var fs = ev.dataTransfer.files;
	
		for(var i = 0 ; i<fs.length ; i++)
		{
			if(fs[i].type.indexOf('image') != -1 )
			{
				var fd = new FileReader();

				//千万注意这里需要将fd放入循环当中
				//不然会报The object is already busy reading Blobs这样的错误
				
				fd.readAsDataURL( fs[i] );
				fd.onload = function()
				{
					var oLi = document.createElement('li');
					var oImg = document.createElement('img');
					//将数据赋值给图片元素的src 图片就能显示出来了
					oImg.src = this.result;

					oLi.appendChild(oImg);
					oUl.appendChild(oLi);
				}
			}else{
				alert('第' + i+1 + '个文件不是图片,请上传图片');	
				continue;
			}
		}
	}
}
{% endhighlight %}

### 一个购物车实例

废话不说,直接上代码
{% highlight Javascript %}
=== html ===
<ul id="ul1">
	<li draggable="true">
		<img src="替换成自己的图片">
		<p>Javascript语言精粹</p>
		<p>40￥</p>
	</li>
	<li draggable="true">
		<img src="替换成自己的图片">
		<p>Javascript权威指南</p>
		<p>120￥</p>
	</li>
	<li draggable="true">
		<img src="替换成自己的图片">
		<p>精通Javascript</p>
		<p>35￥</p>
	</li>
	<li draggable="true">
		<img src="替换成自己的图片">
		<p>DOM编程艺术</p>
		<p>60￥</p>
	</li>
</ul>
<div id="div1">
</div>


=== css ===
*{ margin:0; padding: 0;}
#ul1 li{ list-style: none; width: 200px; font-weight: bold; color:blue; margin:10px; border:1px solid #eda; float:left;}
#ul1 li img{ width: 200px; }
p{ height:20px;border-bottom:1px black dashed; }
#div1{ width:600px; border: 1px solid #000; height: 300px; clear: both; position: relative;}
.box1{float: left;width: 200px;}
.box2{float: left;width: 200px;}
.box3{float: left;width: 200px;}
#allPrice{ position: absolute; bottom: 0; right: 0;}

=== Javascript ===
window.onload = function()
{
	var aLi = document.getElementsByTagName('li');
	var oDiv = document.getElementById('div1');
	var obj = {};
	var allPrice = null;
	var iNum = 0;
	for(var i=0; i<aLi.length ; i++)
	{
		aLi[i].ondragstart = function(ev)
		{
		
			var aP = this.getElementsByTagName('p');
			ev.dataTransfer.setData('title' , aP[0].innerHTML);
			ev.dataTransfer.setData('price' , aP[1].innerHTML);
			
			//设置拖拽时候的图片
			// ev.dataTansfer.setDragImage(this,0,0);

		}
	}

	oDiv.ondragover = function(ev)
	{
		//允许拖拽
		ev.preventDefault();
	}

	oDiv.ondrop = function(ev)
	{
		//防止默认打开
		ev.preventDefault();

		var sTitle = ev.dataTransfer.getData('title');
		var sPrice = ev.dataTransfer.getData('price');
		
		if( !obj[sTitle] )
		{
			var oP = document.createElement('p');
			var oSpan = document.createElement('span');
			oSpan.className = 'box1';
			oSpan.innerHTML = 1;
			oP.appendChild( oSpan );
		
			var oSpan = document.createElement('span');
			oSpan.className = 'box2';
			oSpan.innerHTML = sTitle;
			oP.appendChild( oSpan );

			var oSpan = document.createElement('span');
			oSpan.className = 'box3';
			oSpan.innerHTML = sPrice;
			oP.appendChild( oSpan );

			oDiv.appendChild(oP);

			obj[sTitle] = true;
		}else{
			var box1 = document.getElementsByClassName('box1');
			var box2 = document.getElementsByClassName('box2');

			for(var i = 0;i<box1.length;i++)
			{
				//根据box2的索引找到对应的box1的值
				if(box2[i].innerHTML == sTitle)
				{
					box1[i].innerHTML = parseInt(box1[i].innerHTML) + 1;
				}
			}
		}

		if(!allPrice)
		{
			allPrice = document.createElement('div');
			allPrice.id = 'allPrice';
			oDiv.appendChild( allPrice );
		}
		
		iNum += parseInt(sPrice);
		allPrice.innerHTML = iNum + '￥'
		
	}
}
{% endhighlight %}

## canvas画布

canvas是一个梦幻的标签，利用它配合JS控制，可以在页面上绘制出你想要的任何图案，并且还可以绘制3D效果
首先canvas的引入非常简单

{% highlight Javascript %}

<canvas>
	<span>您的浏览器十分落后，请及时更换</span>
</canvas>

直接在body中引用就行
{% endhighlight %}

引用后，它有一个缺省的宽高值，即300px × 150px

### 基本的操作代码

{% highlight Javascript %}
首先所有的操作都需要先声明绘制环境
getContext('2d');
这个方法会返回一个 CanvasRenderingContext2D 对象，该对象实现了一个画布所使用的大多数方法。
截至目前只支持2d绘图，也许在不久的将来会支持3d
当然没有这样的绘制环境不代表不能实现3d绘图，我们可以使用一些hack手法,但这不是今天我们讨论的重点

canvas的主线是路径，一切基础图形的绘制都需要根据路径来实现

下面是一些基础方法：
fillRect( left , top , width , height) 绘制一个实心矩形
strokeRect( left , top , width , height)  绘制一个空心带边框矩形
fillStyle 填充样式属性可以用来修改颜色
strokeStyle 填充边框样式属性可以用来修改边框的颜色
lineWidth 填充边框大小可以修改边线大小
lineJoin 端点样式 有这么些属性 miter 默认 bevel 斜角 round 圆角
lineCap 端点样式 butt(默认) round(圆角) square(高度多出为要一半的值)
beginPath()  开始绘制路径(线条)
closePath()  结束绘制路径
moveTo( x , y ) 移动到绘制的新目标点
lineTo( x , y ) 新的目标点
Rect( left , top , width , height) 绘制一个矩形路径(不进行填充)
stroke() 根据路径画线
fill() 根据路径填充
clearRect( left , top , width , height ) 清除画布中的某个区域
save() 保存路径
resave() 恢复路径 

然后是基础代码
demo1:
=== css ===
body{background: black;}
canvas{background: white;}

=== html ===
<canvas id = 'canvas1' width='400' height='400'>

=== Javascript ===
var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');
oGc.fillRect(50,50,100,100); 
oGc.strokeRect(50.5,50.5,100,100);

大多数情况下canvas绘制的图片默认是黑色或者黑色透明
空心带边框矩形的边框默认是1px黑色
然而这里会出现两个小问题

1.空心带边距的矩形是按线进行定位而不是按像素点进行定位的
所以如果定位坐标是整数的话，会在这个整数像素点的两边各取半个像素点进行填充(也就是所谓的1px边框)
但是显示器不可能显示半个像素，所以会把这两个只有一半的像素取整，也就是会显示成2px的边框
如果要解决这个问题也很简单，只要绘制的时候将定位坐标设置为多半个像素，就可以了

2.oGc.fillRect(50,50,100,100); 和 oGc.strokeRect(50.5,50.5,100,100);的顺序问题
一个是先填充 一个是先画边框，所以效果会进行覆盖

demo2:
=== css ===
body{background: black;}
canvas{background: white;}

=== html ===
<canvas id = 'canvas1' width='400' height='400'>

=== Javascript ===
var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');
oGc.beginPath();       //开启路径
oGc.moveTo(100 , 100); //定位起始端点
oGc.lineTo(200 , 200); //定位一个端点
oGc.lineTo(300 , 100); //定位另一个端点
oGc.closePath();       //结束绘制并自动将最后一个定位端点和起始点相连接
oGc.stroke();          //根据路径绘制图形

这里有个小问题，每次我们绘制图形的时候 需要有一个beginPath 和 closePath的闭合 
也就是说确认绘制的路径需要闭合，否则会使不同的绘制操作 对所有路径都起效果
简单来说就是需要我们绘制一个图形的时候，一定要有beginPath closePath

demo3:
=== css ===
body{background: black;}
canvas{background: white;}

=== html ===
<canvas id = 'canvas1' width='400' height='400'>

=== Javascript ===
var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');

oGc.save();
oGc.beginPath();       
oGc.moveTo(100 , 100); 
oGc.lineTo(200 , 200); 
oGc.lineTo(300 , 100); 
oGc.closePath();       
oGc.stroke();
oGc.resave();          
//使用save和resave 包含路径 和 路径操作的代码
//如果对路径有样式的操作，这样就不会影响

oGc.beginPath();       
oGc.moveTo(100 , 100); 
oGc.lineTo(200 , 200); 
oGc.lineTo(300 , 200); 
oGc.closePath();       
oGc.stroke();

再介绍一个基本的画图功能

demo4:
=== css ===
body{background: black;}
canvas{background: white;}

=== html ===
<canvas id = 'canvas1' width='400' height='400'>

=== Javascript ===
var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');
var oInput = document.querySelector('#input1');

oGc.strokeStyle = 'red';
oCanvas.onmousedown = function(ev)
{
	var ev = ev || event;
	oGc.moveTo(ev.clientX - oCanvas.offsetLeft , ev.clientY - oCanvas.offsetTop);
	document.onmousemove = function(ev)
	{
		var ev = ev || event;
		oGc.lineTo(ev.clientX - oCanvas.offsetLeft , ev.clientY - oCanvas.offsetTop);
		oGc.stroke();
	}
	document.onmouseup = function()
	{
		document.onmousemove = null;
		document.onmouseup = null;
	}
}

还有一个问题需要注意：
canvas的宽高一定需要在行列样式中设置，不能在内置的样式表中设置
因为内置的样式表中，宽高是根据父元素的宽高等比例设置的
而行列样式才是根据确定数值来设置的

{% endhighlight %}

## 使用canvas绘制圆

使用绘制环境下arc可以绘制圆

arc( x轴半径 , y轴半径 , 圆的半径 , 起始弧度 , 终止弧度 , 是否逆时针绘制 )

1.需要注意的地方是x 、y 和圆的半径 跟上面一样不需要带单位，
2.起始弧度和终止弧度是以弧度制为单位的( 弧度 = 角度*Math.PI/180 );
3.false 是顺时针旋转 true是逆时针旋转
4.绘制的起点是过圆心半径长的x轴正方向方向上的一点,终点当然就是过圆心半径长的x轴负方向上的一点喽。
5.顺时针弧度为正，逆时针弧度为负。

demo如下
{% highlight Javascript %}

css html 上同

=== Javascript ===

var oCanvas = document.querySelector("#canvas1");
var oGc = oCanvas.getContext("2d");

oGc.moveTo(200 , 200);
oGc.arc(200 , 200 , 100 , 0 , 180*Math.PI/180 , true );
oGc.stroke();

{% endhighlight %}

制作一个与本地时间同步的时针

{% highlight Javascript %}
function DrawClock()
{
	var oCanvas = document.querySelector('#canvas1');
	var oGc = oCanvas.getContext('2d');

	var oDate = new Date();
	var oHours = oDate.getHours();
	var oMinutes = oDate.getMinutes();
	var oSeconds = oDate.getSeconds();
	var x = 200;
	var y = 200;
	var r = 150;
	oGc.clearRect( 0 , 0 , oCanvas.width , oCanvas.height );
	// -90度是为了使刻度回归12点与时钟刻度起点保持一致
	var oSecvalues = (-90 + oSeconds*6 ) * Math.PI/180;
	var oMinvalues = (-90 + oMinutes*6 ) * Math.PI/180;  
	//分针每走一格子，时针就要移动2°
	var oHoursValues = (-90 +　oHours*30 + oMinutes * 2) * Math.PI/180;

	oGc.beginPath();
	for(var i = 0;i<60;i++)
	{
		//注意moveTo( x , y )需要每次循环都添加，因为画完一段弧长后需要重新定位绘制点
		oGc.moveTo( x , y );
		oGc.arc( x , y , r , (6*i)*Math.PI/180 , (6*(i+1)*Math.PI/180));
	}
	oGc.closePath();
	oGc.stroke();

	oGc.fillStyle = 'white';
	oGc.beginPath();
	oGc.moveTo( x , y );
	oGc.arc( x , y , r*19/20 , 0 , 360*Math.PI/180);
	oGc.closePath();
	oGc.fill();

	oGc.lineWidth = 3;
	oGc.strokeStyle = '#edc';
	oGc.beginPath();
	for(var i = 0 ; i<12; i++)
	{	
		oGc.moveTo( x , y );
		oGc.arc( x , y , r , (30*i)*Math.PI/180 , (30*(i+1)*Math.PI/180));
	}
	oGc.closePath();
	oGc.stroke();

	oGc.fillStyle = 'white';
	oGc.beginPath();
	oGc.moveTo( x , y );
	oGc.arc( x , y , r*16/20 , 0 , 360*Math.PI/180);
	oGc.closePath();
	oGc.fill();

	oGc.strokeStyle = 'red';
	oGc.lineWidth = 4;
	oGc.lineJoin = 'round';
	oGc.beginPath();
	oGc.moveTo( x ,y );
	oGc.arc( x , y , r*10/20 , oHoursValues , oHoursValues  );
	oGc.closePath();
	oGc.stroke();

	oGc.strokeStyle = '#F90';
	oGc.lineWidth = 2;
	oGc.lineJoin = 'round';
	oGc.beginPath();
	oGc.moveTo( x ,y );
	oGc.arc( x , y , r*12/20 , oMinvalues , oMinvalues );
	oGc.closePath();
	oGc.stroke();

	oGc.strokeStyle = 'green';
	oGc.lineWidth = 1;
	oGc.lineJoin = 'round';
	oGc.beginPath();
	oGc.moveTo( x ,y );
	oGc.arc( x , y , r*15/20 , oSecvalues , oSecvalues );
	oGc.closePath();
	oGc.stroke();

}

setInterval(DrawClock , 1000);
{% endhighlight %}

## 使用canvas绘制曲线

我们还可以使用canvas绘制出曲线
arcTo() : arcTo( 第一组坐标xy  第二组坐标xy 曲线半径 )
什么意思呢？
我们用一张图来了解一下

![shootPic](/assets/img/arcTo-showPic.png)

如图我们可以很好的了解arcTo方法的含义
结合上图，我们可以得到下列代码
{% highlight Javascript %}

html css 上同

var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');

oGc.moveTo( 100 , 200 );

oGc.arcTo( 100 , 100 , 200 , 100 , 50 );
oGc.stroke();
	
{% endhighlight %}

## 用canvas绘制贝塞尔曲线

具体了解贝塞尔曲线，可在本站[关于贝塞尔曲线知识个人理解](http://numerhero.github.io/2015/09/24/about-Bezier-curve.html)了解。

quadraticCurveTo( dx , dy , x1 , y1 ) 一个控制点的贝塞尔曲线
也就是一个二阶的贝塞尔曲线

(dx , dy)是控制点的坐标， (x1 , y1)是结束点的坐标
{% highlight Javascript %}
demo1:
css html 上同

=== Javascript ===

var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');

oGc.moveTo( 100 , 200 );

oGc.quadraticCurveTo( 100 , 50 , 200 , 100 );
oGc.stroke();

{% endhighlight %}

html5还提供了另外一种绘制贝塞尔曲线的方法
bezierCurveTo( dx1 , dy1 , dx2 , dx2 , x1 , y1 ) 两个控制点的贝塞尔曲线
也就是一个三阶的贝塞尔曲线

{% highlight Javascript %}
demo2:
css html 上同

=== Javascript ===

var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');

oGc.moveTo( 100 , 200 );

oGc.bezierCurveTo( 100 , 50 , 200 , 100 , 200 , 50 );
oGc.stroke();

{% endhighlight %}

## 使用canvas变换

### 移动translate

translate( x , y )
以起始点为起点,移动到translate设定的点

### 旋转rotate

rotate( 45*Math.PI/180 ) [注意参数是弧度制,旋转45°]
以起始点为旋转点,旋转到设定的角度

这里有一点需要注意:

如果一个语句里面有两句旋转
rotate( 20*Math.PI/180 );
rotate( 25*Math.PI/180 );

那么旋转的效果会叠加,也就是说会旋转成45°

如果需要产生一个旋转渐变的效果(先旋转20°在到25°)

需要将每个旋转语句用save() 和 restore() 语句包起来
这样就不会出现角度叠加的问题

### 缩放scale

scale( 宽的缩放倍数 , 高的缩放倍数 ) 

scale( 2 , 2 ) 宽高同时放大两倍,面积扩大四倍

### 一个自转缩放的运动的矩形demo

{% highlight Javascript %}
var oCanvas = document.querySelector('#canvas1');
var oGc = oCanvas.getContext('2d');


var num = 0;
var num2 = 0;
var switched = 1;

setInterval(function(){
	num++;

	oGc.save();
	//每次绘制新的画面的时候清除上一帧的画布
	oGc.clearRect( 0 , 0 , oCanvas.width , oCanvas.height );
	
	//移动到正中间
	oGc.translate(200,200);

	if( num2 == 60 )
	{
		switched = -1;
	}else if( num2 == 10 ){
		switched = 1;
	}

	num2 += switched;
	
	// 根据当前计算的num2的值 算出这一帧 需要缩放的度数
	oGc.scale( num2*1/50  , num2*1/50 );

	// 根据当前计算的num1的值 算出这一帧 需要旋转的度数
	oGc.rotate( num*Math.PI/180 );

	// 移动到栋中心点
	oGc.translate( -50 , -50 );

	oGc.fillRect( 0 , 0 , 100 , 100 );
	
	oGc.restore();
},30);


这里有一点要特别注意:就是操作变换的语句执行顺序不能变,如果改变可能会得到不同的效果

比如将控制旋转的语句oGc.rotate( num*Math.PI/180 ); 放在oGc.translate(200,200);之前
那么就会成为一个先按移动前的点旋转,在移动到点( 200 ,200 ) 那就不是自转了！
{% endhighlight %}

## canvas里面drawImage方法

我们可以使用drawImage方法来加载一张图片
drawImage( 图片对象 , 中心点坐标 );

我们可以使用js中的 new Image()方法 创建一个图片对象 并添加它的src
然后在使用drawImage方法绘制在canvas上面

### 一个图片旋转功能

{% highlight Javascript %}
=== html ===
<input type ="button" value="←">
<input type ="button" value="→">
<div>
	<img src="替换成需要添加的图片路径" id="img1">
</div>
=== css ===

body{background: black;}
canvas{background: white;}

=== Javascript ===

var oInput = document.querySelectorAll('input');
var oImg = document.querySelector('#img1');
var yImg = new Image();
var iNow = 0;
yImg.src = oImg.src;

yImg.onload = function()
{
	draw(this);
}

function change( iNow , obj , oCanvas , oGc )
{
	switch( iNow )
	{
		case 1:
		
			// 首先画布大小要随图片旋转的改变而改变
			// 将页面旋转90°后,绘制的时候需要重新定位绘制点
			// 绘制点坐标即旋转后左上角顶点坐标
			oCanvas.width = obj.height;
			oCanvas.height = obj.width;
			oGc.rotate( 90*Math.PI/180 );
			oGc.drawImage( obj , 0 ,-oCanvas.width );
			break;

		case 2:

			oCanvas.width = obj.width;
			oCanvas.height = obj.height;
			oGc.rotate( 180*Math.PI/180 );
			oGc.drawImage( obj , -oCanvas.width , -oCanvas.height );
			break;

		case 3:

			oCanvas.width = obj.width;
			oCanvas.height = obj.height;
			oGc.rotate( 0 );
			oGc.drawImage( obj , 0 , 0 );
			break;
	}
}

function draw(obj)
{
	//根据添加的图片创建一个canvas
	var oCanvas = document.createElement('canvas');
	var oGc = oCanvas.getContext('2d');

	oCanvas.width = obj.width;
	oCanvas.height = obj.height;
	
	//将页面中的<img> 标签替换成 canvas标签
	oImg.parentNode.replaceChild( oCanvas , oImg );
	
	//先初始化，绘制图片 绘制点为 (0 , 0) 点
	oGc.drawImage( obj , 0 , 0 );
	
	//添加点击事件
	oInput[0].onclick = function()
	{
		iNow == 0 ? iNow = 3 : iNow-- ;
		change( iNow , yImg , oCanvas , oGc );		
	}

	oInput[1].onclick = function()
	{
		iNow == 3 ? iNow = 0 : iNow++ ;
		change( iNow , yImg , oCanvas , oGc );
	}
}


{% endhighlight %}

## canvas里面的createPattern方法

这个方法允许我们在canvas里面给绘制的圆或者矩形三角形插入图片背景
和drawImage相比,createPattern显得更加自由


createPattern( 图片对象 背景平铺方式 )

图片对象直接就new Image(); 然后修改src

平铺方式和background相同:repeat 、 repeat-x 、 repeat-y 、 no-repeat

demo:
{% highlight Javascript %}
=== html ===
<canvas id = "Canvas1" width=400 height=400 ></canvas>

=== Css === 

body{background: black;}
canvas{background: white;}

=== Javascript ===

var oCanvas = document.querySelector('#Canvas1');
var oGc = oCanvas.getContext("2d");
var yImg = new Image();
yImg.src = '这里填写你的图片路径';

yImg.onload = function()
{
	draw(this);
}

function draw( obj )
{
	var bg = oGc.createPattern( obj , 'repeat' );

	oGc.fillStyle = bg;
	
	oGc.fillRect( 0 , 0 , 300 , 300 );
}

{% endhighlight %}

## 使用canvas实现渐变

canvas给我们提供了实现颜色渐变的方法

### 线性渐变

createLinearGradient( x1 , y1 , x2 , ,y2 );
addColorStop( 渐变线端点值 , 添加的渐变线颜色 )

渐变的方向和程度由一条渐变线和渐变色占的比例来控制
其中( x1 , y1 )是渐变线的起点 ( x2 , y2 ) 是渐变线的终点
用渐变线的起点表示0,渐变线的终点表示1
那么我们就可以在这条线段中添加不的色段,但是前提是色段点不能超过1

所以createLinearGradient方法会返回一个对象,这个对象底下有一个方法是addColorStop()
通过它我可以在这条渐变线上面添加各种颜色的色段点。但是注意色段点不能超过一

下面我们看一个demo
{% highlight Javascript %}

css和html上同
var oCanvas = document.querySelector('#Canvas1');
var oGc = oCanvas.getContext("2d");

var obj = oGc.createLinearGradient( 150 , 100 , 150 , 150 );

obj.addColorStop( 0 , 'red');
obj.addColorStop( 0.2 , 'blue');
obj.addColorStop( 0.8 , 'pink');
obj.addColorStop( 1 , 'yellow');

oGc.fillStyle = obj;

oGc.fillRect( 150 , 100 , 100 , 100 );

{% endhighlight %}

由此我们可以总结出:canvas中依靠渐变线来控制渐变的起始、终点和方向,addColorStop()控制渐变的程度和颜色

### 放射性渐变


和线性渐变相比我更喜欢放射性渐变。

createRadialGradient( x1 ,y1 , r1 , x2 , y2 , r2 );
原理就是将线性渐变的两个点换成两个圆

其中(x1 , y1)是第一个圆的圆心 r1是这个圆的半径
( x2 , y2 )是第二个院的圆心  r2是这个院的半径

但是放射性渐变和线性渐变有所不同, 线性渐变在渐变过程中将会填充整个绘制的矩形
但是放射性渐变会先过两条圆的切线,将位于矩形内的圆和两条切线组成的面积填充
![shootpic](/assets/img/RadialGradient.png)

{% highlight Javascript %}
css和html上同

var oCanvas = document.querySelector('#Canvas1');
var oGc = oCanvas.getContext("2d");

var obj = oGc.createRadialGradient( 150 , 100 , 25 , 250 , 200 , 0 );

console.log(obj);
obj.addColorStop( 0 , 'red');
obj.addColorStop( 1 , 'yellow');

oGc.fillStyle = obj;

oGc.fillRect( 150 , 100 , 100 , 100 );

{% endhighlight %}

### 关于线性渐变和放射性渐变两者总结

| || 控制点 || 是否支持多个色阶 || 渐变方式 || 是否全部填充 |
|:--------------||:--------------||:--------------||:--------------||:--------------|
| 线性渐变 || 点 || 是 || 由渐变线开始渐变 || 是 |
|:--------------||:--------------||:--------------||:--------------|:--------------|
| 放射性渐变 || 点(r=0)或者圆 || 是 || 由第一个圆的圆心开始渐变,到第二个圆结束 || 从第一个圆到第二个院部分填充 |


## 感谢

本博文，有相当一部分内容COPY 和 引用了他人的知识，特此陈列，以表感谢

[妙味课堂](www.miaov.com)
[IAN MCNALLY 's blog](http://ianmcnally.me/blog/2015/6/25/input-validity-in-the-html-spec)
[history对象](http://blog.csdn.net/hdchangchang/article/details/41959313)
[act262的博客](http://www.cnblogs.com/act262/p/3983039.html)

## 引用出自

### 《javascript高级程序设计》