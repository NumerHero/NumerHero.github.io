---
layout: post
title: NodeJs学习历程
category: 技术
keywords: 技术,nodejs
---

![nodejs](/assets/img/nodejs.jpg)

## Hello World

首先要明白一点,每门语言的实现都需要一个解析器,尽管是同一门语言,

解析器不同就可能导致具体实现的功能不同,对于前端页面来说,解析器便是浏览器程序。
Ecmascript5 的用处是操作各种DOM结点来完成页面的各种功能、布局样式的修改和特效，
所以浏览器便提供了Document Object Model 和 Brower Object Model 来方便Ecmascript5 操纵页面

所以说在浏览器端 

由Ecmascript5 + DOM + BOM 就组成了我们所谓的Javascript

而在后端服务器方面

因为具体需要用来操作磁盘文件和搭建服务器,所以这时候的解析器就不是浏览器程序了。
而nodejs就充当了解析器这么一个角色

也就是说`nodejs并不是一门语言,而是一个后端的解析器,或者说一种后端的运行环境`

nodejs为了能让我们更好的完成它的用途也给我们提供了如 http , fs 等等的内置模块(类比DOM BOM)

nodejs可以说是前端人员了解后端的一个切入点所在(当然php也很适合)
这样前端人员就可以在他们的老本行的基础上调用封装好后端脚本框架了

## 配置sublime 快速编译

很简单（个人觉得比webstrom 简单）

只需要在sublime中找到

工具-->编译系统-->新编译系统

然后sublime就会弹出一个 `untitled.sublime-build`,将untitled 改成nodejs 然后再将里面原有的文本替换成
{% highlight Javascript %}
{
    "cmd": ["node", "$file"],
    "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)",
    "working_dir": "${project_path:${folder}}",
    "selector": "source.js",
    "shell": true,
    "encoding": "utf-8",
    "windows": {
        "cmd": ["node", "$file"]
    }
}
{% endhighlight %}

保存到默认的目录下，就可以了，sublime会自动检测已经安装好的nodeJS
然后再
工具-->编译系统-->自动编译

这样sublime 会根据程序来识别不同的script，进行不同编译

这样，当你写好一个js文件，只要直接 `ctrl + b` sublime 就会自动调用nodeJS进行编译

## node基础

nodeJs 基础 和 js 基础一致，都是ecmascript

所以ecmascript底下的所有东西，都可以使用

{% highlight Javascript %}
var  a = new Date();
console.log( a.getFullYear() );
console.log( a.getMonth() + 1 );
console.log( a.getDate() );
console.log( a.getHours() );
console.log( a.getMinutes() );
console.log( a.getSeconds() );


var arr = [];

arr.push.apply( arr , [1,2,3] );
arr.push.apply( arr , [4,5,6] );
arr.push.apply( arr , [7,8,9] );

console.log(arr);

function run(name) {
	this.name = name;
}

run.prototype.runfuc = function() {
	console.log( this.name );
}

var b = new run('owen');
b.runfuc();
{% endhighlight %}

以上代码都可以编译运行

还有一点，就是在nodeJs中，最上层的对象不是`window`而是`global`
global 也是ecmascript中定义的一个最上层的对象，但不对外访问，js中的window其实是global的一个引用

## 模块
nodejs实现功能是以不同个模块来完成的

nodejs规定一个js文件就是一个模块，不同模块有自己的作用域
我们使用`var` 在一个js文件里面声明的变量只是该模块下的局部变量
如果需要声明全局变量，我们可以使用`global`声明
{% highlight Javascript %}
global.a = 200;
console.log(global.a); // 200
{% endhighlight %}

我们还可以通过`__filename`变量来访问当前被解析模块的路径字符串
每一个模块中都有一个`__filename` 
{% highlight Javascript %}
console.log(__filename); // D:\NodeJs\text\global-problem.js
{% endhighlight %}

## 模块加载系统

我们可以使用`require`来引入模块，类似java中的`import`
{% highlight Javascript %}
require('模块路径');
{% endhighlight %}

所引入的模块会自动被解析执行。



首先使用前我们都需要这样加载这样一个http模块

{% highlight Javascript %}
var http = require('http');
{% endhighlight %}

这样我们就可以使用这个模块返回的对象来新建一个网络服务

{% highlight Javascript %}
// 创建一个本地服务环境,并设置端口为localhost:8888
var serve = http.createServer().listen(8888);
{% endhighlight %}

这个函数会返回一个回调函数,这个函数会产生两参数 
分别存储用户`请求的信息和方法` 和 `服务器响应的数据和方法`

{% highlight Javascript %}

// 回调匿名函数,并返回request 和 reponse
var serve = http.createServer( function( request , reponse ){
	
	// 我们可以在这个函数里面写一些监听响应事件
	
	respone.writeHeader( http状态码 , 头部信息声明(json形式) )

	// 一个脚本内只能有一个respone.end不然会报错

	respone.writeHeader( 200 , {'Content-Type' : 'text/html;charset="utf-8"'});
	respone.write("Hello World 欢迎");
	respone.end("该次响应请求已结束");

} ).listen(8888);
{% endhighlight %}

我们使用fs加载一个文件模块,通过文件模块我们可以根据客户端的请求来响应为用户提供对应的页面文件

{% highlight Javascript %}
var fs = require("fs");
{% endhighlight %}

通过fs.readFile() 来为用户提供不同的文件页面
调用这个函数需要传入两个参数 一个是请求的文件的路径(字符串) 一个是一个回调函数

这个回调函数返回两个参数,一个是 error错误信息参数,如果请求的内容没有找到或者出错,
就会返回一个包含错误信息的JSON回来
{% highlight Javascript %}
{ [Error: EISDIR: illegal operation on a directory, read] errno: -4068, code: 'EISDIR', syscall: 'read' }
{% endhighlight %}

如果并没有出错,则返回null

另一个获得的文件数据

如果获取成功获得的是一个xml的buffer标签,返回的是加密过的文件16进制编码
如果获取失败则得到的是null

## 一个简单的demo

{% highlight Javascript %}
// 加载http模块
var http = require('http');

// 建立完请求之后,执行回调函数 函数需要声明两个形参, request 和 respone

// 设置一个www文件记录下本站的根目录路径(www文件夹下可以放我们站内需要的页面文件和资源)
var documentRoot = 'D:/Wampserver/html5test/websockt/www'/

// fs加载文件模块
var fs = require('fs');

console.log( "Server running at http://localhost 8888 " );

var httpServer = http.createServer(function(request , respone)
{
	// request方法接收用户请求的内容
	// respone方法实现对用户请求服务器的发送
	
	console.log("有用户建立了访问");

	var url = request.url;

	var file = documentRoot + url;
	console.log('用户请求的文件路径' + file);
	
	// 读取文件
	fs.readFile( file , function( err , data )
	{
		if( err )
		{
			respone.writeHeader( 404 , {
				'content-Type' : 'text/html;charset="utf-8"'
			});
			respone.write("<h1>404错误</h1>")
			respone.end();
		}else{
			respone.writeHeader( 200 , {
				'content-Type' : 'text/html;charset="utf-8"'
			});
			respone.write( data );
			respone.end();
		}
		
	});	

}).listen(8888);


{% endhighlight %}


## 感谢

[妙味课堂](http://www.miaov.com)

[在nodeJs 下部署功能模块](http://m.blog.csdn.net/blog/designpc/9722549)

[cNode 关于http模块基础](https://cnodejs.org/topic/513b5601df9e9fcc58a9efae)

[7天学会nodejs ? ](http://nqdeng.github.io/7-days-nodejs/)

[npm包管理工具](http://www.tuicool.com/articles/VB7nYn)

[粉丝日记](http://blog.fens.me/series-nodejs/)