---
layout: post
title: Css3 学习历程
category: 技术
keywords: 技术,css3
---

## 属性选择器

我们可以通过属性选择器,选出带有特定的属性的标签元素

{% highlight html %}

<style>
	li{height:30px; border:1px solid #000; list-style:none; margin:5px;}
	li[lavender]{background: red;}
</style>

<ul>
	<li lavender="owen" >owen</li>
	<li lavender="zye"  >zye</li>
	<li lavender="ppt"  >ppt</li>
</ul>

{% endhighlight %}

想上面demo演示一样,我们可以通过同一种属性找到所对应的标签元素,并将他们全部变成红色

{% highlight css %}
	
	li[lavender=owen]{background:yellow;}

{% endhighlight %}

如果想修改特定的属性的标签样式,可以这么写

每一个属性都是一个词列表,也就是说多个标签里面可以有多个属性名(以空格隔开),如果需要从这个列表中选择特定的属性可以使用~=来选出具有特定属性名的标签元素

{% highlight html %}

<style>
	li{height:30px; border:1px solid #000; list-style:none; margin:5px;}
	li[lavender~=owen]{background: yellow;}
</style>

<ul>
	<li lavender="owen handsome" >owen</li>
	<li lavender="zye"  >zye</li>
	<li lavender="ppt"  >ppt</li>
</ul>

{% endhighlight %}

注意:~= 和 = 的区别, = 是要属性名完全相同才可以选取, 而~=是属性中只要有这个属性就能选取

当然上面这样获取可能比较麻烦,如果不想每次获取属性都打一次属性名的话,可以使用^=来获取

这样

{% highlight css %}
	li[lavender^=o]{background:yellow;}
{% endhighlight %}

这样只要是o开头的属性名就能被获取到,如果有多个o开头的属性,可以再加上后面的字母直到完全和其他属性名不同为止

这里owen handsome 就获取到了o开头的标签

当然能获取第一个属性开头也就有获取第一个属性结尾的方法,这里我们使用$=

{% highlight css %}
	li[lavender$=n]{background:yellow;}
{% endhighlight %}

这样通过$= 我们可以找到属性owen handsome结尾的e,然后将这个标签变成黄色

我们还可以通过*= 找到含有特定字母的标签

比如 zye 和 owne handsome 两个属性中都有e
{% highlight css %}
	li[lavender*=e]{background:yellow;}
{% endhighlight %}

我们就可以*=e找到对应的两个标签

最后一个也是最特殊的属性选择器,他规定只要是 `某个特定字母-` 和 `单独的某个特定字母` 开头的属性
{% highlight html %}

<style>
	li{height:30px; border:1px solid #000; list-style:none; margin:5px;}
	li[lavender|=b]{background: yellow;}
</style>

<ul>
	<li lavender="b-owen handsome" >owen</li>
	<li lavender="g-zye"  >zye</li>
	<li lavender="bppt"  >ppt</li>
	<li lavender="b"  >b</li>
</ul>

{% endhighlight %}

如上面所示, 含有b-owen handsome 和 b的元素都会被获取到,然而有b开头的 bppt 和 g-zye都不会被获取到

## 结构性伪类选择器 

除了通过属性选择html元素外,Css3还允许我们通过结构伪类来选择对应的元素

{% highlight html %}

<style>
	p{height:30px; border:1px solid #000;}
</style>

<p>
	p1
</p>
<p>
	p2
</p>
<p>
	p3
</p>
<p>
	p4
</p>
<p>
	p5
</p>

{% endhighlight %}

例如这里所有的p标签,我们可以通过结构选择器来选择其中任意的p标签来实现不同的样式
{% highlight css %}

	p:nth-child(1){background:yellow;}
	p:nth-child(2){background:red;}
	p:nth-child(3){background:red;}
{% endhighlight %}



p:nth-child(数字)   即所有p标签对应的父级的第几个p标签,这样理解起来很拗口,还是再举个例子吧
{% highlight html %}
<ul>
	<p></p>
	<li></li>
	<p></p>
</ul>

<ul>
	<p></p>
	<li></li>
	<p></p>
</ul>

上面有两个Ul ul下有p标签有li标签
这时候加一句
<style> 	
	p:nth-child(2){background:red;}
</style>

这样就会先找到所有p标签的父节点, 也就是两个ul标签 然后再找到这个父节点下的第二个结点,
然后判断是否也是p结点,如果也是p结点那么就修改样式

那么上面这么的布局结构,所有ul下的第二个结点都是li,那p:nth-child就没有任何效果

如果我们改变一下他们的位置
<ul>
	<p></p>
	<p></p>
	<li></li>
</ul>

<ul>
	<p></p>
	<p></p>
	<li></li>
</ul>

就可以发现所有ul 下的p 标签效果出现了
{% endhighlight %}

注意:这里结构性伪类选择器是以1开始计数的,不同于js

同时,nth-child后面不单单填数字,还可以选择奇数(odd)和偶数(even)
我们还可以让所有的奇数行变色
{% highlight css %}

	p:nth-child(odd){background:yellow;}

{% endhighlight %}

偶数行
{% highlight css %}

	p:nth-child(even){background:pink;}

{% endhighlight %}

结构性伪类选择器还支持n这么一个参数,n取0到正无穷.然后从n到∞开始遍历,知道遍历完成所有的标签
我们这样我们就可以通过添加参数n的写法来获取奇偶数行了

注意：元素获取是从1开始的,但是n却是从0开始的

奇数行:
{% highlight css %}

	p:nth-child(2n-1){background:pink;}

{% endhighlight %}

偶数行:
{% highlight css %}

	p:nth-child(2n){background:pink;}

{% endhighlight %}

和nth-child所对应的还有一个nth-last-child 
他俩唯一的区别就是nth-child从前往后数 , nth-last-child是从后往前数,其他的功能都相同

还有一个nth-of-type,我们还是以刚刚那个例子为例
{% highlight html %}
<ul>
	<p></p>
	<li></li>
	<p></p>
</ul>

<ul>
	<p></p>
	<li></li>
	<p></p>
</ul>

<style> 	
	p:nth-of-type(2){background:red;}
</style>

刚刚使用nth-child的时候,我们获取的是每个ul下的第二个结点,然后判断是否是p结点,如果是则加样式,不是则不加

所以每个ul下的第二个标签是li和所选取的p不符合,也就没有任何样式

但是,如果我们这里写的是nth-of-type的话,却能将每个ul下的第二个p结点找到并加样式
说明,nth-of-type获取的不是每个ul下的第二个结点 而是根据选取的标签来匹配第几个元素

{% endhighlight %}



但是,如过我们现在把所匹配的东西换成类呢？
{% highlight html %}

<ul>
	<p class="abc"></p>
	<li class="abc"></li>
	<p class="abc"></p>
</ul>

<ul>
	<p class="abc"></p>
	<li class="abc"></li>
	<p class="abc"></p>
</ul>

我们再style里添加这个语句
<style>
	.abc:nth-of-type(2){background: red;}
</style>

那么会以什么形式获取呢？

结果是获取每个ul下的第二个p

如果我们把结构再换一下
<ul>
	<li class="abc"></li>
	<p class="abc"></p>
	<li class="abc"></li>
</ul>

<ul>
	
	<li class="abc"></li>
	<p class="abc"></p>
	<li class="abc"></li>
</ul>

那么这时候获取的又是li

如果我们再换一下这样
<ul>
	<p class="abc"></p>
	<li class="abc"></li>
	<p class="abc"></p>
</ul>

<ul>
	<li class="abc"></li>
	<p class="abc"></p>
	<li class="abc"></li>
</ul>

那么获取的是 第一个ul里的第二个p  和 第二个ul 里面的第一个p

那么我们就看出来了,如果是获取类的话,流程是:先根据不同父级的第一个类的标签获取父级,再从该父级中找到对应标签的第几个元素

那么以此类推 nth-child再获取类的时候也是如此,都是根据第一个类来决定获取什么元素
{% endhighlight %}

当然一样的 也有nth-last-of-type 和 nth-of-type寻取元素顺序相反,但其他功能相同


当然还有什么

first-child 
last-child
first-of-type
last-of-type
only-child
only-of-type
empty

感觉比较鸡肋

只要牢牢记住
nth-child是 根据结点寻找,并且找的结点要和选择的结点标签(或者类名)要一致      (不一定能找的到)
nth-of-type 是根据所匹配的标签(或者第一个类名)寻找                           (一定能找的到)

结构性伪类我认为基本上就够了

nth-child  和 nth-of-type 个人认为实在弄得太复杂,但是功能还是很强大的.慎用


## 伪类和伪类元素

:target
当我们点击锚点,产生目标的时候触发修改其样式

[demo](/assets/download/Pseudo-class1.html)

### 表单伪类

:enabled
当表单可以执行的时候呈现的样式

:disabled
当表单不可执行的时候呈现的样式

[enabled 和 disabled 的 demo](/assets/download/Pseudo-class2.html)

:checked
当选框选中时候呈现的样式(可以是单选也可以是多选)

:indeterminate
单选框还未进行选择的时候的样式
用户选择后样式消失

[checked 和 indeterminate](/assets/download/Pseudo-class3.html)

我们可以使用checked制作一个自定属性的单选按钮

[一个自定义单选框](/assets/download/Pseudo-class4.html)

### 文本伪类

:first-line 选取第一行文本并修改样式

:first-letter 选取第一个文字(如果使用了这个伪类那就无法进行选取了)

::selection 改变选取文本高亮样式

::after 和 ::before (在文本前面添加内容 和 后面添加内容)
也可做:afer 和 :before,还可以用来制作小箭头和解决bfc问题(重要)


:not(s)排除多个或者一个的样式

{% highlight html %}
<style>
	h1:not(.not){background: red;}
</style>

<body>
	<h1>h1</h1>
	<h1 class="not">h1</h1>
	<h1 class="not">h1</h1>
	<h1>h4</h1>
	<h1>h5</h1>
	<h1>h6</h1>
	<h1>h7</h1>
</body>

这里我给所有h1设置了红色,但是用:not()排除了所有带.not的h1标签
{% endhighlight %}

## 新增颜色模式

Css3里面新增了rgba颜色模式,可以允许我们单独调节调节单层文本或者布局的透明度
(不影响父级或子级的透明度)

我们还可以使边框变成半透明
{% highlight css %}
	#box{ width:100px; height:100px; border:10px solid rgba(255,255,255,0.5);}
{% endhighlight %}

## 新增颜色HSLA模式

HSLA模式即声明使用 色调(Hue) 、 饱和度(Saturation) 、 亮度(Lightness) 和 透明度(Alpha) 来设定颜色,使用和上文提到的rgba颜色模式相同

{% highlight css %}
	#box{ width:100px; height:100px; background:hsla(165, 35%, 50%, 0.2);}
{% endhighlight %}

其中Hue衍生于色盘 0和360是红色，接近120的是绿色，240是蓝色。

Saturation值是一个百分比：0%是灰度，100%饱和度最高

Lightness值也是一个百分比：0%是最暗，50%均值，100%最亮。

Alpha 使用和上文相同

而HSLA模式在各大标准浏览器中都获得了良好的支持而且无需添加浏览器内核前缀

## 文字阴影

text-shadow: x轴偏移 , y轴偏移 , 向外扩展度 , 颜色;

通过文字阴影我们可以制作文字描边
{% highlight css %}
	text-shadow: 0 , 0 , 1px red;
{% endhighlight %}
可替代 只有 -webkit- 支持的文字描边 -webkit-text-stroke: 宽度 颜色;

我们可以对文字添加多层阴影
{% highlight css %}
	text-shadow: 0 0 5px red,5px 0 5px pink,0 5px 5px yellow;
{% endhighlight %}

用逗号隔开可以添加多次阴影(多次添加阴影会影响浏览器性能)

我们可以来看一下妙味给我们提供的一些文字效果

[光晕效果](/assets/download/text-shadow1.html)

[文字模糊](/assets/download/text-shadow2.html)

[火焰文字](/assets/download/text-shadow3.html)

## 文本排列

direction 定义文字排列方式

direction: rtl 或者 ltr; (right to left 或者 left to right)

如果设置了rtl,则文本整个从右到左排列,但是文本阅读方向还是默认的从右到左

如果需要设置文本阅读方向,我们在加上uncode-bi-di:bidi-override;
实现文本从右到左阅读

兼容ie6+

## 超出文字显示省略号

当我们需要应对超出文字的时候(标题太长超出范围的时候)
可以使用overflow:hidden;来隐藏文本, 但是这样有时候会将处于超出边缘的文字一分两半,就影响效果。

这样我们需要一种既能隐藏超出文字,有不影响用户体验的方法,就可以加省略号来代替隐藏

首先浏览器对超出文字的处理默认是超出自动换行的,我们需要将其设置为非默认隐藏
{% highlight css %}
	white-space:nowrap;
{% endhighlight %}
然后overflow:hidden;将溢出的文字隐藏,这时候就会出现上文提到的问题

这时候就使用css3给我们提供的 text-overflow:Ellipsis (显示省略号)
如果我们不想要省略号可以写clip 这样就能处理掉那些溢出一半的文字

## FontFace

当我们需要在网页中添加一些特殊的字体,可以使用facefont引用字体包让用户一起加载

但是不同的浏览器对字体文件的格式支持的不同,所以我们需要将一个字体文件格式化
为不同的字体格式

老外呢就给我们提供了这么一个网站
[fontsquirrel](http://www.fontsquirrel.com/fontface/generator)

当我们获得不同格式的字体文件之后,我们只要在css中添加这样的代码
{% highlight css %}
@font-face {
    font-family: 'newfontstyle'; /*字体类名可以自定义*/
    src: url('需要引用的字体文件名.eot');
    src: url('需要引用的字体文件名.eot?#iefix') format('embedded-opentype'),
         url('需要引用的字体文件名.woff') format('woff'),
         url('需要引用的字体文件名.ttf') format('truetype'),
         url('需要引用的字体文件名.svg#untitledregular') format('svg');
    font-weight: normal;
    font-style: normal;
}

/*这样就可以直接用这种字体了*/

h1{font-family:'newfontstyle';}
{% endhighlight %}

但是中文字体比较麻烦,中文常用的字都有几千个,而英文就那26个字母
这就产生了问题:

① 中文字体文件转格式特别麻烦
② 中文字体文件特别大影响网页加载

而腾讯的ISUX团队开发了字蛛中文字体压缩器(基于node)

从而解决了这个问题
具体可见

[设计师的春天：中文WebFont解决方案Font-Spider(字蛛)](http://isux.tencent.com/zh-hans/font-spider.html)

[字蛛官网](http://font-spider.org/)

## 弹性盒模型

### display:box 和 box-flex

我们先来看一个例子

[demo](/assets/download/display-box.html)

{% highlight html %}

<style>
	.wrap{
		width:600px;
		height: 200px;
		display:box;  /*也可以设置成inline-box效果都是一样的*/
	}
	.sectionFirst{
		background:orange; 
		box-flex:3; 
	}
	.sectionSecond{ 
		background:purple; 
		box-flex:2;
	}
	.sectionThird{
		background:green; 
		box-flex:1;
	}
</style>

<article class="wrap">
	<section class="sectionFirst">01</section>
	<section class="sectionSecond">02</section>
	<section class="sectionThird">03</section>
</article>

/*注:这里我将浏览器内核前缀省略了,因为我希望技术讨论应该注重精华*/

{% endhighlight %}


这里有一个大的盒子,当我们给wrap。当我们给他设置`display:box;`的时候我们就可以对他进行弹性分配了

注意这里底下的子标签 01 02 03 我都没有给他们设置宽高,
但是给了他们这么一个东西`box-flex` 更具它设置子级所获得的父级的空间期权
这样父级的空间就这么按照期权的比例分成 1 + 2 + 3 = 6 份 那么一份就是 width:100px; height:200px;

然后根据根据1:2:3的比例子级进行分割父级的空间

但是如果我们将其中一个只设为固定宽高呢？
{% highlight css %}
	.sectionSecond{ 
		background:purple;
		width:200px;
		height:100px;
	}
{% endhighlight %}

这样父级就会先为这个设置了固定宽高的子级分配宽高,然后在将剩下的空间根据flex期权来分配

如果固定宽高已经将父级的空间分配完毕了,那么flex及失效

如果一个元素既分配固定宽高又有flex期权,那么两者不冲突,两种效果将叠加

其次,眼尖的同学一定会发现,我并没有给子级设置`float:left;` 但是子级却可以从左到右排列开来,而且子级还可以设置自己的固定样式

这说明如果给父子设置display:box; 那么子级等于自动加上了`display:inline-box;`
(尽管firebug中显示的子级的布局还是`display:block`)至于为什么,下文会提到

这里还有一个问题,我很疑惑,在其他标准浏览器中,我可以给添加了`display:box;`的盒子再加上居中`margin:0 auto;` 但是在火狐下,却无法设置左右居中
看来C3的标准制定还是任重道远

### box-orient

从上文看来只要给父级设置了`display:box;`我们就可以对父级底下的子级进行一系列操作了
除了用flex来动态的分配空间外,我们还可以使用orient来控制子级的排列

orient(英:标定方向,东方的)可选的值有:

horizontal(水平) | vertical(垂直) | inline-axis(内联轴) | block-axis(块轴) | inherit

这个值设置对象是父级,作用效果是全部子级元素(不能给某个子级单独设置)

上面提到了,当我们给父级设置`display:box` 自己会默认`display:inline-block`
这就是因为 `box-orient` 的初始值是`inline-axis` 然后子级默认就是`display:block`

所以两个效果叠加起来就变成了`display:inline-block`的效果 

如果把orient修改成block-axis那么就等于取消了inline-block的效果,那么这时候所有的子级元素都会变成像块状元素一样独占一行了。
(但是注意即使变成了默认的块状元素也不能加浮动,如果加了浮动就会脱离父级`display:box;`的控制)

而垂直和水平呢,则是单纯的控制子级的水平垂直排列,不会改变元素的display

这个属性感觉特别有用,这样我们再也不需要使用`margin:0 auto;`和`position:absolute; top:50%; left:50%来进行居中了


### box-direction

上文我们曾提到text-direction来控制文字的排列,那么类比文字的排列,我们就很容易理解box-direction的用处了

这个值同样只给父级设定,作用全部子级

可选的值有:

Normal | Reverse(反向) | inherit

### box-ordinal-group

ordinal(英:序数的)-group可以设定不同子级元素的初始位置

{% highlight css %}
	.sectionFirst{background:orange; 
		box-flex:3;
		box-ordinal-group:2
	}
	.sectionSecond{ background:purple;  
		box-flex:2;
		box-ordinal-group:1;
	 }
	.sectionThird{ background:green;
		box-flex:1;
		box-ordinal-group:3;
	}

	/*同样的我还是省略浏览器内核前缀*/
{% endhighlight %}

这样我们就可以随意打乱所布局好的子级元素,又不脱离文档流。

### box-pack

我们可以在父级设定`box-pack`来对子级和空闲空间进行管理

当然如果已经子级已经通过flex把父级的空间全部分配完了,那么这个属性设置了也没什么用了

pack(英:包,一组)可选的值:

Start | End | Center | Justify(英:证明,整齐排列) | inherit

如果设置了start 那么所有子元素在盒子左侧显示，空闲空间在右侧
end 那么所有子元素在盒子右侧显示，空闲空间在左侧
center 那么所有子元素居中,空闲空间在两侧
Justify 那么空闲空间与子元素之间整齐分布

### box-align

上文说到的`box-pack` 如果我们设置为center那么就可以实现x轴水平居中,但是如果我们需要对y轴进行居中,却要用到box-align

align()可选的值:

Start | End | Center 

start 自然就是让全部子元素屯在父级顶部了,默认值也是Start

End 以此类推当然就是让全部子元素屯在父级底部了

center 实现垂直方向水平居中

还有注意浏览器兼容问题 至少在本人撰写这篇文章的时候关于`display:box;`的相关Css属性还是需要添加浏览器内核前缀

我们可以给body标签设置`display:box;`这样就能更好的控制底下的子元素和空闲空间了,布局也就会轻松很多

## box-shadow

就想text-shadow Css3也可以为盒模型提供阴影

box-shadow : 投影方式(选填) X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径(选填) 颜色

来看一个简单demo
{% highlight css %}
	box-shadow: 0 0 30px 30px pink;	
{% endhighlight %}

[demo1](/assets/download/box-shadow1.html)

如果我们要内阴影那么只要再加一个参数就ok了
{% highlight css %}
	box-shadow:inset 0 0 30px 30px pink;	
{% endhighlight %}

如果不填写那么就是默认的外投影

[demo2](/assets/download/box-shadow2.html)

## box-reflect

我们可以使用box-reflect来制作盒的投影

box-felect 方向 投影和本影间距 渐变(选填)

{% highlight css %}
	box-felect: right;

	/*省略了浏览器内核前缀*/	
{% endhighlight %}

[demo1](/assets/download/box-reflect1.html)

这样可以镜像出一个右原本的倒影

如果给倒影加上渐变呢？

{% highlight css %}
box-reflect:right 50px linear-gradient(left,rgba(0,0,0,1) 0,rgba(0,0,0,0) 100%);	
/*省略了浏览器内核前缀*/
{% endhighlight %}

[demo2](/assets/download/box-reflect2.html)

## resize

Css3中允许我们让盒子自由的拖拽(重新改变盒子的大小)

只要给盒子加上resize属性 并且吧overflow：属性设置为auto 你就可以拖动右下角来改变盒子的宽高
{% highlight css %}
 #box{width: 100px; height: 100px;  resize:both; overflow:auto;}
{% endhighlight %}

[demo](/assets/download/resize1.html)

其中resize可有的属性:

both 水平垂直都可以缩放
horizontal 只有水平方向可以缩放
vertical 只有垂直方向可以缩放
none 不拖拽

textarea标签默认resize:both
如果不希望用户玩坏你的页面最好清一下
{% highlight css %}
 texttarea{ resize:none; }
{% endhighlight %}

## box-sizing

很逆天的一玩意,可以修改盒模型尺寸计算的规则

可选参数:
content-box: border和padding不计算入width之内

padding-box: padding计算入width内

border-box: border和padding计算入width之内，其实就是怪异模式了~

使用的时候需要加上浏览器内核前缀

[demo](/asset/download/box-sizing.html)

## 分栏式文字布局

Css3中还提供分栏式的文字布局供我们使用

如果你希望你写的文字内容,在一个盒子里以分栏的形式出现,我们可以为他设置分栏布局

先看一个[demo](/assets/download/column1.html)

这里我设定了让一大块的文字,分栏布局,每一栏的宽度是10em*16 = 160px
这里我没有设置column-count,那么浏览器就会自主决定将文本分成合适的列数
{% highlight css %}
 column-width: 10em;
{% endhighlight %}

这里分栏式布局有这么几个属性
column-width : 设置每一分栏的宽度,浏览器会自动决定文本分成合适的栏数
column-count : 分栏栏数,设置后浏览器会自动计算宽度,并设置成相应的栏数
column-gap   : 设置两个栏目之间的宽度
column-rule  : 设置分栏列间的分割线
columns      : 分栏布局简写

这里注意,column-width column-gap 和 column-count 都会改变分栏的列数和栏数,
首先为了不冲突,请尽量经过合理的计算后再设定样式

如果冲突了(比如一个900px的盒子,我让他分栏宽度为160px,但却只设两列,那么肯定不能完全填满盒子的)
浏览器会自动选择一个折中的办法,来进行分栏.

而且,Css3还提供了columns属性可以允许我们简写
如果我们设定是宽度,只要我们给属性带上单位,那么column-width可以这么写
{% highlight css %}
 columns: 10em;
/* 等同于 column-width: 10em; */
{% endhighlight %}
如果我们设定的是列数,只要我们不给属性单位,那么column-count就可以这么写
{% highlight css %}
 columns: 2;
/* 等同于 column-count: 2; */
{% endhighlight %}

如果我们宽度列数都要设定,那么可以这样写
{% highlight css %}
 columns: 2 10em;
/* 等同于 column-count: 2; + column-width */
/* 两个参数顺序可以互逆 */
{% endhighlight %}

但是columns只支持column-count 和 column-width 的简写,其他属性还是要照常写

如果我们要给分栏添加分栏线
{% highlight css %}
column-rule:3px solid #000;
{% endhighlight %}


还要注意:本人在撰写这篇博文的时候,关于分栏式布局的全部样式还必须添加上浏览器内核前缀

## 圆角

如果需要在原来的浏览器上实现圆角的效果,需要通过切图,再使用双层嵌套来实现
但是在Css3便很容易就可以实现圆角的效果。而且圆角对各个标准浏览器都已经实现兼容

圆角的实现原理

![picshoot](/assets/img/broder-radius.png)

如图,在Css3中圆角的实现是依靠,对一个角x轴偏移 和 y轴偏移来实现的

{% highlight css %}
	border-radius:5px;	
{% endhighlight %}

这是最简单的实现4个角呈圆角,即令四个角的X、Y轴都偏移5像素

在X、Y偏移量相同的情况下,如果我们想要让四个角的的X、Y偏移量不同,可以尝试这种写法

{% highlight css %}
	border-radius:5px 10px 15px 20px;	
{% endhighlight %}

那么顺序是从左上→右上→右下→左下(顺时针排列)

如果需要对角相同的话,可以尝试2个参数的写法

{% highlight css %}
	border-radius:10px 20px;	
{% endhighlight %}

这样写的顺序是左上角和右上角 → 右上角和右下角

{% highlight css %}
	border-radius:10px 15px 20px;	
{% endhighlight %}

如果是三个参数呢,那么就是从左上角 → 右上角和左下角 → 右下角

以上的情况都是X、Y轴相同,但是角不同的例子
如果需要细致的控制X Y轴的偏移度的话,可以这么写

{% highlight css %}
	border-radius:10px/20px;	
{% endhighlight %}

这种情况就是,四个角都相同,都是X轴偏移10px , Y轴偏移20px

两个参数、三个参数、四个参数的写法(所对应的角的顺序都是相同的)

两个参数:
{% highlight css %}
	border-radius:10px 15px/20px 25px;	
{% endhighlight %}

三个参数:
{% highlight css %}
	border-radius:10px 15px 20px/20px 25px 30px;	
{% endhighlight %}

四个参数:

{% highlight css %}
	border-radius:10px 15px 20px 25px/20px 25px 30px 35px;	
{% endhighlight %}

如果我们要画一个圆那么最简单的方法保证宽高相等

{% highlight css %}
	border-radius:50% 50%;	
{% endhighlight %}

绘制一个椭圆的话
{% highlight css %}
	border-radius:50%/50%;	
{% endhighlight %}

## 边框背景

### border-image-sourceg

Css3中还提供了这么一个属性border-image来允许我们给边框添加自定义的图片
如果单纯只设border-image的话,那么自定义的图片将会分配在盒子的四个角上

{% highlight css %}
	border-image:url(边框背景路径);	
{% endhighlight %}

[demo](/assets/download/border-image-demo1.html)

### border-width

这个边框的宽度直接设置就行
{% highlight css %}
	border-width:100px;	
{% endhighlight %}

或者上下左右
{% highlight css %}
	border-top-width:100px;
	border-bottom-width:100px;
	border-left-width:100px;
	border-right-width:100px;	
{% endhighlight %}

但是如果我们要真正的将背景变成一个边框背景而不是四个角的背景的话
我们需要对背景图片进行切割

### border-image-slice

当然边框背景所需要的图片也不是,随随便便就能拿张图片过来用的,一张标准的边框背景图片需要以一种九宫格的方式呈现

![picshoot](/assets/img/border-image2.png)

如图所示,当我们拿到一张边框背景图的时候,我们需要先将其切四刀分成九份

其中四个角格子所占的图片,分别对应一个盒子的四个角。而上下左右的格子则会被拉伸,平铺或者重复成为一个盒子的四条边

![picshoot](/assets/img/border-image1.gif)

如图我们来写border-image最基本的语句
{% highlight css %}
	border-image:url(边框背景路径) 从左位移n个像素竖直切割 从上位移n个像素水平切割
	从右位移n个像素竖直切割 从下位移n个像素水平切割 四边延伸方法	
{% endhighlight %}

切割方向也是采用顺时针的方式

或者两重参数
{% highlight css %}
	border-image:url(边框背景路径) 上下两边切 左右两边切 四边延伸方法	
{% endhighlight %}

当进行完图片分割后,就能看到成形的边框背景了
(这里说明一点,当没有设置四边延伸方法的时候,默认的方式是拉伸,所以demo2中四边被拉伸了)
[demo2](/assets/download/border-image-demo2.html)

### border-image-repeat 
当然切割完图片还不够,需要配合合适的延伸方法才可以

拉伸(stretch) 将四边图片背景进行拉伸(即demo2相同)

平铺(round) 将四边图片进行平铺,首先会计算是否会以整数个四边背景平铺,如果不能整齐的平铺,则会将四边图片合理的缩小一些,在进行平铺

[demo3](/assets/download/border-image-demo3.html)

重复(repeat) 直接简单的将四边背景进行重复,边缘可能会出现残缺

[demo4](/assets/download/border-image-demo4.html)


## border-colors

给边框叠加不同颜色(目前只有火狐下实现了 还需要添加浏览器内核前缀)

[demo](/assets/download/border-colors.html)

{% highlight css %}
border-top-colors: red pink yellow green;
/* 可以叠加n种颜色,可重复,颜色之间用空格隔开 */
{% endhighlight %}

还有注意是colors 不是 color

## 渐变

CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）。而我们今天主要是针对线性渐变来剖析其具体的用法。

### 线性渐变

渐变还是作为盒子背景实现的,所以需要在background-image中实现

线性渐变第一参数需要指明一个方向,这个方向可以是上下左右,也可以是左上左下右上下。还支持一种使用deg(偏转度数)

如果不写第一个参数,那么默认方向是从上到下

先写一个简单的从顶向下的渐变
{% highlight css %}
box{background-image:linear-gradient:top,red,blue;}
/* 从上到下由红色渐变成蓝色 */
{% endhighlight %}

[demo](/assets/download/linear-gradient1.html)

当然如果是左上呢
{% highlight css %}
box{background-image:linear-gradient:top left,red,blue;}
/* 第二个方向用空格隔开 */
{% endhighlight %}

那么我们再看deg(多数时候使用的都是deg,因为比较自由),当0deg的时候方向是从左到右
{% highlight css %}
box{background-image:linear-gradient:30deg,red,blue;}
/* 正deg从X轴逆时针旋转,负deg从X轴顺时针旋转 */
{% endhighlight %}

第一个参数之后就全部是渐变的颜色,这个颜色什么时候开始渐变的参数了

{% highlight css %}
box{background-image:linear-gradient(45deg,red 160px,blue 480px,yellow 960px);}
{% endhighlight %}

[demo](/assets/download/linear-gradient2.html)

这是什么意思呢？
我根据张鑫旭的博客中[深入理解CSS3 gradient斜向线性渐变](http://www.zhangxinxu.com/wordpress/2013/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3css3-gradient%E6%96%9C%E5%90%91%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98/)这篇文章画了了这么张图

![picshoot](/assets/img/linear-gradient.png)

其中的160px、480px、960px都是从起始点到渐变起点和渐变终点的距离

当然起始点可能画的不准确,但是这里主要解释的是原理

这里一定要注意两点,越后面的开始渐变的参数一定要比前面的参数大,不然就不会出现渐变效果。同时也不能超出盒子的范围,不然就看不到这个渐变色了

线性渐变里面还支持一个repeating-linear-gradient平铺渐变

只要在渐变的前面加上repeating就可以实现重复渐变的效果
{% highlight css %}
box{background-image:repeating-linear-gradient(45deg,red 160px,blue 480px,yellow 960px)}
{% endhighlight %}

[demo](/assets/download/linear-gradient3.html)

### 径向渐变

## 感谢

[妙味课堂](www.miaov.com)

[张鑫旭的博客](http://www.zhangxinxu.com/wordpress/2010/12/css-box-flex%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/)

[CSS3系列教程:HSL 和HSLA](http://www.hen9hen9.com/seo/html/?658.html)

[zhaoran关于box-sizing的解释](http://www.cnblogs.com/zhaoran/archive/2013/05/24/3097482.html)

[web骇客 关于分栏式布局的用法](http://www.webhek.com/css3-multi-columns)